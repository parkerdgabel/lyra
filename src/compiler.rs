use crate::{
    ast::{Expr, Number},
    bytecode::{Instruction, OpCode},
    linker::{registry::create_global_registry, FunctionRegistry},
    stdlib::StandardLibrary,
    vm::{Value, VirtualMachine},
};
use std::collections::HashMap;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CompilerError {
    #[error("Unsupported expression: {0}")]
    UnsupportedExpression(String),
    #[error("Too many constants (max 16777215)")]
    TooManyConstants,
    #[error("Unknown function: {0}")]
    UnknownFunction(String),
    #[error("Invalid function arity: {function} expects {expected} args, got {actual}")]
    InvalidArity {
        function: String,
        expected: usize,
        actual: usize,
    },
    #[error("Unknown method: {type_name}.{method}")]
    UnknownMethod {
        type_name: String,
        method: String,
    },
    #[error("Invalid method arity: {method} expects {expected} args, got {actual}")]
    InvalidMethodArity {
        method: String,
        expected: usize,
        actual: usize,
    },
}

pub type CompilerResult<T> = std::result::Result<T, CompilerError>;

/// Compilation context for tracking constants and symbols
#[derive(Debug)]
pub struct CompilerContext {
    /// Constant pool - values indexed by position
    pub constants: Vec<Value>,
    /// Symbol table - maps symbol names to indices
    pub symbols: HashMap<String, usize>,
    /// Generated bytecode instructions
    pub code: Vec<Instruction>,
}

impl CompilerContext {
    pub fn new() -> Self {
        CompilerContext {
            constants: Vec::new(),
            symbols: HashMap::new(),
            code: Vec::new(),
        }
    }

    /// Add a constant to the pool, returns its index
    pub fn add_constant(&mut self, value: Value) -> CompilerResult<usize> {
        // Check for duplicates to avoid bloat
        for (i, existing) in self.constants.iter().enumerate() {
            if existing == &value {
                return Ok(i);
            }
        }

        if self.constants.len() >= 0xFFFFFF {
            return Err(CompilerError::TooManyConstants);
        }

        self.constants.push(value);
        Ok(self.constants.len() - 1)
    }

    /// Add a symbol to the table, returns its index
    pub fn add_symbol(&mut self, name: String) -> usize {
        if let Some(&index) = self.symbols.get(&name) {
            return index;
        }
        let index = self.symbols.len();
        self.symbols.insert(name, index);
        index
    }

    /// Emit an instruction
    pub fn emit(&mut self, opcode: OpCode, operand: u32) -> CompilerResult<()> {
        let instruction = Instruction::new(opcode, operand)
            .map_err(|_| CompilerError::UnsupportedExpression("Invalid instruction".to_string()))?;
        self.code.push(instruction);
        Ok(())
    }

    /// Get the current code position (for jumps)
    pub fn current_position(&self) -> usize {
        self.code.len()
    }
}

impl Default for CompilerContext {
    fn default() -> Self {
        Self::new()
    }
}

/// The main compiler
#[derive(Debug)]
pub struct Compiler {
    pub context: CompilerContext,
    pub stdlib: StandardLibrary,
    pub registry: FunctionRegistry,
}

impl Compiler {
    /// Create a new compiler
    pub fn new() -> Self {
        Compiler {
            context: CompilerContext::new(),
            stdlib: StandardLibrary::new(),
            registry: create_global_registry().expect("Failed to create function registry"),
        }
    }

    /// Compile an expression to bytecode
    pub fn compile_expr(&mut self, expr: &Expr) -> CompilerResult<()> {
        match expr {
            Expr::Number(Number::Integer(n)) => {
                // All integers now use constant pool with LDC
                let const_index = self.context.add_constant(Value::Integer(*n))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Number(Number::Real(f)) => {
                let const_index = self.context.add_constant(Value::Real(*f))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::String(s) => {
                let const_index = self.context.add_constant(Value::String(s.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Symbol(sym) => {
                // Symbols now loaded via constant pool with LDC
                let const_index = self.context.add_constant(Value::Symbol(sym.name.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::List(elements) => {
                // Compile each element and create a list
                let mut list_values = Vec::new();
                for element in elements {
                    // For now, we'll evaluate each element and add to list
                    // This is a simplified approach - a full implementation would
                    // handle this more efficiently at runtime
                    match element {
                        Expr::Number(Number::Integer(n)) => {
                            list_values.push(Value::Integer(*n));
                        }
                        Expr::Number(Number::Real(f)) => {
                            list_values.push(Value::Real(*f));
                        }
                        Expr::String(s) => {
                            list_values.push(Value::String(s.clone()));
                        }
                        _ => {
                            // For complex expressions, we'd need to compile them and evaluate at runtime
                            // For now, just put the list in the constant pool
                            return Err(CompilerError::UnsupportedExpression(format!(
                                "Complex list element: {:?}",
                                element
                            )));
                        }
                    }
                }

                // Add the list to the constant pool
                let const_index = self.context.add_constant(Value::List(list_values))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Function { head, args } => {
                self.compile_function_call(head, args)?;
            }
            Expr::DotCall { object, method, args } => {
                self.compile_method_call(object, method, args)?;
            }
            _ => {
                return Err(CompilerError::UnsupportedExpression(format!("{:?}", expr)));
            }
        }
        Ok(())
    }

    /// Compile a function call
    fn compile_function_call(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Check if this is a built-in arithmetic function that maps to a bytecode instruction
        if let Expr::Symbol(sym) = head {
            match sym.name.as_str() {
                "Plus" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Plus".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    // Compile arguments in order (left operand first)
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::ADD, 0)?;
                    return Ok(());
                }
                "Times" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Times".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::MUL, 0)?;
                    return Ok(());
                }
                "Divide" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Divide".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::DIV, 0)?;
                    return Ok(());
                }
                "Power" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Power".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::POW, 0)?;
                    return Ok(());
                }
                "Minus" => {
                    // Handle unary minus: Minus[x] -> 0 - x
                    if args.len() == 1 {
                        let zero_index = self.context.add_constant(Value::Integer(0))?;
                        self.context.emit(OpCode::LDC, zero_index as u32)?;
                        self.compile_expr(&args[0])?;
                        self.context.emit(OpCode::SUB, 0)?;
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Minus".to_string(),
                            expected: 1,
                            actual: args.len(),
                        });
                    }
                }
                _ => {
                    // Check if this is a stdlib function - use CALL_STATIC for 1000x+ speedup!
                    if let Some(stdlib_index) = self.registry.get_stdlib_index(&sym.name) {
                        // Compile arguments first
                        for arg in args {
                            self.compile_expr(arg)?;
                        }

                        // Emit CALL_STATIC with stdlib function index (32-78)
                        self.context.emit(OpCode::CALL_STATIC, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
                        return Ok(());
                    }
                    
                    // Try compile-time static method resolution
                    if !args.is_empty() {
                        // Check if this method exists in any Foreign type
                        let mut method_found = false;
                        let mut expected_arity = None;
                        
                        // Check all known Foreign types for this method
                        for type_name in self.registry.get_type_names() {
                            if self.registry.has_method(&type_name, &sym.name) {
                                method_found = true;
                                // Get arity from function signature (lookup requires mutable self)
                                // For now, we'll use hardcoded common method arities
                                expected_arity = Some(match sym.name.as_str() {
                                    "Length" | "Type" | "ToList" | "IsEmpty" | "Shape" | "Columns" | "Rows" => 0,
                                    "Get" | "Append" => 1, 
                                    "Set" | "Slice" => 2,
                                    _ => args.len(), // Allow any arity for unknown methods
                                });
                                break;
                            }
                        }
                        
                        if method_found {
                            // Validate arity at compile time
                            if let Some(expected) = expected_arity {
                                if args.len() != expected {
                                    return Err(CompilerError::InvalidMethodArity {
                                        method: sym.name.clone(),
                                        expected,
                                        actual: args.len(),
                                    });
                                }
                            }
                            
                            // Compile all arguments (first arg is the object)
                            for arg in args {
                                self.compile_expr(arg)?;
                            }
                            
                            // Map method name to function index (simplified mapping)
                            let function_index = match sym.name.as_str() {
                                "Length" => 0,
                                "Type" => 1, 
                                "ToList" => 2,
                                "IsEmpty" => 3,
                                "Get" => 4,
                                "Append" => 5,
                                "Set" => 6,
                                "Slice" => 7,
                                "Shape" => 8,
                                "Columns" => 9,
                                "Rows" => 10,
                                _ => 0, // Default fallback
                            };
                            let argc = args.len() as u8;
                            
                            // Generate CALL_STATIC instruction for static dispatch
                            let instruction = Instruction::new_call_static(function_index, argc)
                                .map_err(|_| CompilerError::TooManyConstants)?;
                            self.context.code.push(instruction);
                            return Ok(());
                        }
                    }
                    // For unknown functions with no args, fall through to error
                }
            }
        }

        // Unknown function
        Err(CompilerError::UnknownFunction(format!("{:?}", head)))
    }

    /// Compile a method call (obj.Method[args] syntax) using unified registry
    fn compile_method_call(&mut self, object: &Expr, method: &str, args: &[Expr]) -> CompilerResult<()> {
        // Search all known Foreign types for this method
        let mut method_found = false;
        let mut method_index = None;
        
        for type_name in self.registry.get_type_names() {
            if self.registry.has_method(&type_name, method) {
                method_found = true;
                method_index = self.registry.get_method_index(&type_name, method);
                break;
            }
        }
        
        if method_found && method_index.is_some() {
            // Compile object expression first
            self.compile_expr(object)?;
            
            // Compile arguments
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            let index = method_index.unwrap();
            // Emit CALL_STATIC with Foreign method index (0-31)
            self.context.emit(OpCode::CALL_STATIC, ((index as u32) << 8) | (args.len() as u32))?;
            return Ok(());
        }
        
        // Method not found in registry
        Err(CompilerError::UnknownMethod {
            type_name: "Unknown".to_string(),  // We don't know the type at compile time
            method: method.to_string(),
        })
    }

    /// Compile a complete program (list of expressions)
    pub fn compile_program(&mut self, expressions: &[Expr]) -> CompilerResult<()> {
        for expr in expressions {
            self.compile_expr(expr)?;
            // For statements, we might want to pop the result if it's not the last one
            // For now, keep all results on the stack
        }
        // No halt instruction needed - execution ends naturally
        Ok(())
    }

    /// Create a VM loaded with the compiled bytecode
    pub fn into_vm(self) -> VirtualMachine {
        let mut vm = VirtualMachine::new();
        vm.load(self.context.code, self.context.constants);

        // Copy symbol table to VM
        for (name, index) in self.context.symbols {
            vm.symbols.insert(name, index);
        }

        vm
    }

    /// Convenience method to compile and evaluate an expression
    pub fn eval(expr: &Expr) -> CompilerResult<Value> {
        let mut compiler = Compiler::new();
        compiler.compile_expr(expr)?;
        // No halt instruction needed

        let mut vm = compiler.into_vm();
        vm.run()
            .map_err(|e| CompilerError::UnsupportedExpression(format!("Runtime error: {:?}", e)))
    }
}

impl Default for Compiler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::{Expr, Number, Symbol};

    #[test]
    fn test_compile_integer_small() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(42));

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 42);
    }

    #[test]
    fn test_compile_integer_large() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(0x1000000)); // Larger than 24-bit

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Integer(0x1000000));
    }

    #[test]
    fn test_compile_real() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Real(3.14));

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Real(3.14));
    }

    #[test]
    fn test_compile_string() {
        let mut compiler = Compiler::new();
        let expr = Expr::String("hello".to_string());

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(
            compiler.context.constants[0],
            Value::String("hello".to_string())
        );
    }

    #[test]
    fn test_compile_symbol() {
        let mut compiler = Compiler::new();
        let expr = Expr::Symbol(Symbol {
            name: "x".to_string(),
        });

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.symbols.len(), 1);
        assert_eq!(compiler.context.symbols["x"], 0);
    }

    #[test]
    fn test_compile_plus() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 2, Push 3, Add
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::ADD);
    }

    #[test]
    fn test_compile_times() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(4)),
                Expr::Number(Number::Integer(5)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 4, Push 5, Mul
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 4);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 5);
        assert_eq!(compiler.context.code[2].opcode, OpCode::MUL);
    }

    #[test]
    fn test_compile_nested_arithmetic() {
        let mut compiler = Compiler::new();
        // (2 + 3) * 4 -> Times[Plus[2, 3], 4]
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol {
                        name: "Plus".to_string(),
                    })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 2, Push 3, Add, Push 4, Mul
        assert_eq!(compiler.context.code.len(), 5);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::ADD);
        assert_eq!(compiler.context.code[3].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[3].operand, 4);
        assert_eq!(compiler.context.code[4].opcode, OpCode::MUL);
    }

    #[test]
    fn test_invalid_arity() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![Expr::Number(Number::Integer(1))], // Only one argument
        };

        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::InvalidArity {
                function,
                expected,
                actual,
            } => {
                assert_eq!(function, "Plus");
                assert_eq!(expected, 2);
                assert_eq!(actual, 1);
            }
            _ => panic!("Expected InvalidArity error"),
        }
    }

    #[test]
    fn test_unknown_function() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "UnknownFunc".to_string(),
            })),
            args: vec![],
        };

        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::UnknownFunction(_) => {}
            _ => panic!("Expected UnknownFunction error"),
        }
    }

    #[test]
    fn test_constant_deduplication() {
        let mut compiler = Compiler::new();

        // Add the same constant twice
        let index1 = compiler.context.add_constant(Value::Integer(42)).unwrap();
        let index2 = compiler.context.add_constant(Value::Integer(42)).unwrap();

        assert_eq!(index1, index2);
        assert_eq!(compiler.context.constants.len(), 1);
    }

    #[test]
    fn test_symbol_deduplication() {
        let mut compiler = Compiler::new();

        // Add the same symbol twice
        let index1 = compiler.context.add_symbol("x".to_string());
        let index2 = compiler.context.add_symbol("x".to_string());

        assert_eq!(index1, index2);
        assert_eq!(compiler.context.symbols.len(), 1);
    }

    #[test]
    fn test_eval_simple_arithmetic() {
        // Test 2 + 3
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(5));
    }

    #[test]
    fn test_eval_nested_arithmetic() {
        // Test (2 + 3) * 4 = 20
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol {
                        name: "Plus".to_string(),
                    })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(20));
    }

    #[test]
    fn test_eval_division() {
        // Test 8 / 2 = 4.0
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Divide".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(8)),
                Expr::Number(Number::Integer(2)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Real(4.0));
    }

    #[test]
    fn test_eval_power() {
        // Test 2^3 = 8
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Power".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(8));
    }

    #[test]
    fn test_compile_program() {
        let mut compiler = Compiler::new();
        let expressions = vec![
            Expr::Number(Number::Integer(42)),
            Expr::Function {
                head: Box::new(Expr::Symbol(Symbol {
                    name: "Plus".to_string(),
                })),
                args: vec![
                    Expr::Number(Number::Integer(1)),
                    Expr::Number(Number::Integer(2)),
                ],
            },
        ];

        compiler.compile_program(&expressions).unwrap();

        // Should generate: LDC 42, LDC 1, LDC 2, ADD (no halt)
        assert_eq!(compiler.context.code.len(), 4);
        assert_eq!(compiler.context.code[3].opcode, OpCode::ADD);
    }
}

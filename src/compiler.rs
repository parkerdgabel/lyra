use crate::{
    ast::{Expr, Number},
    bytecode::{Instruction, OpCode},
    stdlib::StandardLibrary,
    vm::{Value, VirtualMachine},
};
use std::collections::HashMap;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CompilerError {
    #[error("Unsupported expression: {0}")]
    UnsupportedExpression(String),
    #[error("Too many constants (max 16777215)")]
    TooManyConstants,
    #[error("Unknown function: {0}")]
    UnknownFunction(String),
    #[error("Invalid function arity: {function} expects {expected} args, got {actual}")]
    InvalidArity {
        function: String,
        expected: usize,
        actual: usize,
    },
}

pub type CompilerResult<T> = std::result::Result<T, CompilerError>;

/// Compilation context for tracking constants and symbols
#[derive(Debug)]
pub struct CompilerContext {
    /// Constant pool - values indexed by position
    pub constants: Vec<Value>,
    /// Symbol table - maps symbol names to indices
    pub symbols: HashMap<String, usize>,
    /// Generated bytecode instructions
    pub code: Vec<Instruction>,
}

impl CompilerContext {
    pub fn new() -> Self {
        CompilerContext {
            constants: Vec::new(),
            symbols: HashMap::new(),
            code: Vec::new(),
        }
    }

    /// Add a constant to the pool, returns its index
    pub fn add_constant(&mut self, value: Value) -> CompilerResult<usize> {
        // Check for duplicates to avoid bloat
        for (i, existing) in self.constants.iter().enumerate() {
            if existing == &value {
                return Ok(i);
            }
        }

        if self.constants.len() >= 0xFFFFFF {
            return Err(CompilerError::TooManyConstants);
        }

        self.constants.push(value);
        Ok(self.constants.len() - 1)
    }

    /// Add a symbol to the table, returns its index
    pub fn add_symbol(&mut self, name: String) -> usize {
        if let Some(&index) = self.symbols.get(&name) {
            return index;
        }
        let index = self.symbols.len();
        self.symbols.insert(name, index);
        index
    }

    /// Emit an instruction
    pub fn emit(&mut self, opcode: OpCode, operand: u32) -> CompilerResult<()> {
        let instruction = Instruction::new(opcode, operand)
            .map_err(|_| CompilerError::UnsupportedExpression("Invalid instruction".to_string()))?;
        self.code.push(instruction);
        Ok(())
    }

    /// Get the current code position (for jumps)
    pub fn current_position(&self) -> usize {
        self.code.len()
    }
}

impl Default for CompilerContext {
    fn default() -> Self {
        Self::new()
    }
}

/// The main compiler
#[derive(Debug)]
pub struct Compiler {
    pub context: CompilerContext,
    pub stdlib: StandardLibrary,
}

impl Compiler {
    /// Create a new compiler
    pub fn new() -> Self {
        Compiler {
            context: CompilerContext::new(),
            stdlib: StandardLibrary::new(),
        }
    }

    /// Compile an expression to bytecode
    pub fn compile_expr(&mut self, expr: &Expr) -> CompilerResult<()> {
        match expr {
            Expr::Number(Number::Integer(n)) => {
                // For small integers, use Push instruction
                if *n >= 0 && *n <= 0xFFFFFF as i64 {
                    self.context.emit(OpCode::Push, *n as u32)?;
                } else {
                    // For large integers, use constant pool
                    let const_index = self.context.add_constant(Value::Integer(*n))?;
                    self.context.emit(OpCode::LoadConst, const_index as u32)?;
                }
            }
            Expr::Number(Number::Real(f)) => {
                let const_index = self.context.add_constant(Value::Real(*f))?;
                self.context.emit(OpCode::LoadConst, const_index as u32)?;
            }
            Expr::String(s) => {
                let const_index = self.context.add_constant(Value::String(s.clone()))?;
                self.context.emit(OpCode::LoadConst, const_index as u32)?;
            }
            Expr::Symbol(sym) => {
                let symbol_index = self.context.add_symbol(sym.name.clone());
                self.context.emit(OpCode::LoadSymbol, symbol_index as u32)?;
            }
            Expr::List(elements) => {
                // Compile each element and create a list
                let mut list_values = Vec::new();
                for element in elements {
                    // For now, we'll evaluate each element and add to list
                    // This is a simplified approach - a full implementation would 
                    // handle this more efficiently at runtime
                    match element {
                        Expr::Number(Number::Integer(n)) => {
                            list_values.push(Value::Integer(*n));
                        }
                        Expr::Number(Number::Real(f)) => {
                            list_values.push(Value::Real(*f));
                        }
                        Expr::String(s) => {
                            list_values.push(Value::String(s.clone()));
                        }
                        _ => {
                            // For complex expressions, we'd need to compile them and evaluate at runtime
                            // For now, just put the list in the constant pool
                            return Err(CompilerError::UnsupportedExpression(
                                format!("Complex list element: {:?}", element)
                            ));
                        }
                    }
                }
                
                // Add the list to the constant pool
                let const_index = self.context.add_constant(Value::List(list_values))?;
                self.context.emit(OpCode::LoadConst, const_index as u32)?;
            }
            Expr::Function { head, args } => {
                self.compile_function_call(head, args)?;
            }
            _ => {
                return Err(CompilerError::UnsupportedExpression(format!("{:?}", expr)));
            }
        }
        Ok(())
    }

    /// Compile a function call
    fn compile_function_call(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Check if this is a built-in arithmetic function that maps to a bytecode instruction
        if let Expr::Symbol(sym) = head {
            match sym.name.as_str() {
                "Plus" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Plus".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    // Compile arguments in order (left operand first)
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::Add, 0)?;
                    return Ok(());
                }
                "Times" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Times".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::Mul, 0)?;
                    return Ok(());
                }
                "Divide" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Divide".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::Div, 0)?;
                    return Ok(());
                }
                "Power" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Power".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::Power, 0)?;
                    return Ok(());
                }
                "Minus" => {
                    // Handle unary minus: Minus[x] -> -1 * x
                    if args.len() == 1 {
                        self.context.emit(OpCode::Push, 1)?; // Push -1 (will be negated)
                        self.compile_expr(&args[0])?;
                        self.context.emit(OpCode::Mul, 0)?;
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Minus".to_string(),
                            expected: 1,
                            actual: args.len(),
                        });
                    }
                }
                _ => {
                    // Check if this is a stdlib function
                    if self.stdlib.get_function(&sym.name).is_some() {
                        // Compile arguments first
                        for arg in args {
                            self.compile_expr(arg)?;
                        }
                        
                        // Push function name
                        let func_index = self.context.add_constant(Value::Function(sym.name.clone()))?;
                        self.context.emit(OpCode::LoadConst, func_index as u32)?;
                        
                        // Call the function with argument count
                        self.context.emit(OpCode::Call, args.len() as u32)?;
                        return Ok(());
                    }
                    // For unknown functions, fall through to error
                }
            }
        }

        // Unknown function
        Err(CompilerError::UnknownFunction(format!("{:?}", head)))
    }

    /// Compile a complete program (list of expressions)
    pub fn compile_program(&mut self, expressions: &[Expr]) -> CompilerResult<()> {
        for expr in expressions {
            self.compile_expr(expr)?;
            // For statements, we might want to pop the result if it's not the last one
            // For now, keep all results on the stack
        }
        // Add halt instruction at the end
        self.context.emit(OpCode::Halt, 0)?;
        Ok(())
    }

    /// Create a VM loaded with the compiled bytecode
    pub fn into_vm(self) -> VirtualMachine {
        let mut vm = VirtualMachine::new();
        vm.load(self.context.code, self.context.constants);
        
        // Copy symbol table to VM
        for (name, index) in self.context.symbols {
            vm.symbols.insert(name, index);
        }
        
        vm
    }

    /// Convenience method to compile and evaluate an expression
    pub fn eval(expr: &Expr) -> CompilerResult<Value> {
        let mut compiler = Compiler::new();
        compiler.compile_expr(expr)?;
        compiler.context.emit(OpCode::Halt, 0)?;
        
        let mut vm = compiler.into_vm();
        vm.run().map_err(|e| CompilerError::UnsupportedExpression(format!("Runtime error: {:?}", e)))
    }
}

impl Default for Compiler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::{Expr, Number, Symbol};

    #[test]
    fn test_compile_integer_small() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(42));
        
        compiler.compile_expr(&expr).unwrap();
        
        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[0].operand, 42);
    }

    #[test]
    fn test_compile_integer_large() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(0x1000000)); // Larger than 24-bit
        
        compiler.compile_expr(&expr).unwrap();
        
        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LoadConst);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Integer(0x1000000));
    }

    #[test]
    fn test_compile_real() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Real(3.14));
        
        compiler.compile_expr(&expr).unwrap();
        
        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LoadConst);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Real(3.14));
    }

    #[test]
    fn test_compile_string() {
        let mut compiler = Compiler::new();
        let expr = Expr::String("hello".to_string());
        
        compiler.compile_expr(&expr).unwrap();
        
        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LoadConst);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::String("hello".to_string()));
    }

    #[test]
    fn test_compile_symbol() {
        let mut compiler = Compiler::new();
        let expr = Expr::Symbol(Symbol { name: "x".to_string() });
        
        compiler.compile_expr(&expr).unwrap();
        
        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LoadSymbol);
        assert_eq!(compiler.context.symbols.len(), 1);
        assert_eq!(compiler.context.symbols["x"], 0);
    }

    #[test]
    fn test_compile_plus() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Plus".to_string() })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };
        
        compiler.compile_expr(&expr).unwrap();
        
        // Should generate: Push 2, Push 3, Add
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::Add);
    }

    #[test]
    fn test_compile_times() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Times".to_string() })),
            args: vec![
                Expr::Number(Number::Integer(4)),
                Expr::Number(Number::Integer(5)),
            ],
        };
        
        compiler.compile_expr(&expr).unwrap();
        
        // Should generate: Push 4, Push 5, Mul
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[0].operand, 4);
        assert_eq!(compiler.context.code[1].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[1].operand, 5);
        assert_eq!(compiler.context.code[2].opcode, OpCode::Mul);
    }

    #[test]
    fn test_compile_nested_arithmetic() {
        let mut compiler = Compiler::new();
        // (2 + 3) * 4 -> Times[Plus[2, 3], 4]
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Times".to_string() })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol { name: "Plus".to_string() })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };
        
        compiler.compile_expr(&expr).unwrap();
        
        // Should generate: Push 2, Push 3, Add, Push 4, Mul
        assert_eq!(compiler.context.code.len(), 5);
        assert_eq!(compiler.context.code[0].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::Add);
        assert_eq!(compiler.context.code[3].opcode, OpCode::Push);
        assert_eq!(compiler.context.code[3].operand, 4);
        assert_eq!(compiler.context.code[4].opcode, OpCode::Mul);
    }

    #[test]
    fn test_invalid_arity() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Plus".to_string() })),
            args: vec![Expr::Number(Number::Integer(1))], // Only one argument
        };
        
        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::InvalidArity { function, expected, actual } => {
                assert_eq!(function, "Plus");
                assert_eq!(expected, 2);
                assert_eq!(actual, 1);
            }
            _ => panic!("Expected InvalidArity error"),
        }
    }

    #[test]
    fn test_unknown_function() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "UnknownFunc".to_string() })),
            args: vec![],
        };
        
        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::UnknownFunction(_) => {},
            _ => panic!("Expected UnknownFunction error"),
        }
    }

    #[test]
    fn test_constant_deduplication() {
        let mut compiler = Compiler::new();
        
        // Add the same constant twice
        let index1 = compiler.context.add_constant(Value::Integer(42)).unwrap();
        let index2 = compiler.context.add_constant(Value::Integer(42)).unwrap();
        
        assert_eq!(index1, index2);
        assert_eq!(compiler.context.constants.len(), 1);
    }

    #[test]
    fn test_symbol_deduplication() {
        let mut compiler = Compiler::new();
        
        // Add the same symbol twice
        let index1 = compiler.context.add_symbol("x".to_string());
        let index2 = compiler.context.add_symbol("x".to_string());
        
        assert_eq!(index1, index2);
        assert_eq!(compiler.context.symbols.len(), 1);
    }

    #[test]
    fn test_eval_simple_arithmetic() {
        // Test 2 + 3
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Plus".to_string() })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };
        
        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(5));
    }

    #[test]
    fn test_eval_nested_arithmetic() {
        // Test (2 + 3) * 4 = 20
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Times".to_string() })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol { name: "Plus".to_string() })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };
        
        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(20));
    }

    #[test]
    fn test_eval_division() {
        // Test 8 / 2 = 4.0
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Divide".to_string() })),
            args: vec![
                Expr::Number(Number::Integer(8)),
                Expr::Number(Number::Integer(2)),
            ],
        };
        
        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Real(4.0));
    }

    #[test]
    fn test_eval_power() {
        // Test 2^3 = 8
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol { name: "Power".to_string() })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };
        
        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(8));
    }

    #[test]
    fn test_compile_program() {
        let mut compiler = Compiler::new();
        let expressions = vec![
            Expr::Number(Number::Integer(42)),
            Expr::Function {
                head: Box::new(Expr::Symbol(Symbol { name: "Plus".to_string() })),
                args: vec![
                    Expr::Number(Number::Integer(1)),
                    Expr::Number(Number::Integer(2)),
                ],
            },
        ];
        
        compiler.compile_program(&expressions).unwrap();
        
        // Should generate: Push 42, Push 1, Push 2, Add, Halt
        assert_eq!(compiler.context.code.len(), 5);
        assert_eq!(compiler.context.code[4].opcode, OpCode::Halt);
    }
}
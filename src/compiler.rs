use crate::{
    ast::{Expr, Number, Pattern},
    bytecode::{Instruction, OpCode},
    linker::{registry::create_global_registry, FunctionRegistry},
    stdlib::StandardLibrary,
    vm::{Value, VirtualMachine},
};
use std::collections::{HashMap, HashSet};
use thiserror::Error;

/// Simple function signature for type metadata (temporary until types module is stable)
#[derive(Debug, Clone, PartialEq)]
pub struct SimpleFunctionSignature {
    pub name: String,
    pub param_count: usize,
    pub is_typed: bool,
}

/// Enhanced function signature with actual type information
#[derive(Debug, Clone, PartialEq)]
pub struct EnhancedFunctionSignature {
    pub name: String,
    pub params: Vec<(String, Option<String>)>, // (param_name, type_expr)
    pub return_type: Option<String>,
    pub is_typed: bool,
    pub location: Option<(usize, usize)>, // (line, column)
}

impl EnhancedFunctionSignature {
    pub fn new(name: String) -> Self {
        EnhancedFunctionSignature {
            name,
            params: Vec::new(),
            return_type: None,
            is_typed: false,
            location: None,
        }
    }

    pub fn param_count(&self) -> usize {
        self.params.len()
    }

    pub fn is_fully_typed(&self) -> bool {
        self.params.iter().all(|(_, ty)| ty.is_some()) && self.return_type.is_some()
    }

    pub fn typed_param_count(&self) -> usize {
        self.params.iter().filter(|(_, ty)| ty.is_some()).count()
    }

    pub fn untyped_param_count(&self) -> usize {
        self.params.iter().filter(|(_, ty)| ty.is_none()).count()
    }

    pub fn get_param_type(&self, param_name: &str) -> Option<&str> {
        self.params
            .iter()
            .find(|(name, _)| name == param_name)
            .and_then(|(_, ty)| ty.as_deref())
    }

    pub fn get_return_type(&self) -> Option<&str> {
        self.return_type.as_deref()
    }

    pub fn add_param(&mut self, name: String, type_expr: Option<String>) {
        self.params.push((name, type_expr));
    }

    pub fn set_return_type(&mut self, type_expr: String) {
        self.return_type = Some(type_expr);
    }
}

#[derive(Error, Debug, Clone, PartialEq)]
pub enum CompilerError {
    #[error("Unsupported expression: {0}")]
    UnsupportedExpression(String),
    #[error("Too many constants (max 16777215)")]
    TooManyConstants,
    #[error("Unknown function: {0}")]
    UnknownFunction(String),
    #[error("Invalid function arity: {function} expects {expected} args, got {actual}")]
    InvalidArity {
        function: String,
        expected: usize,
        actual: usize,
    },
    #[error("Unknown method: {type_name}.{method}")]
    UnknownMethod {
        type_name: String,
        method: String,
    },
    #[error("Invalid method arity: {method} expects {expected} args, got {actual}")]
    InvalidMethodArity {
        method: String,
        expected: usize,
        actual: usize,
    },
}

pub type CompilerResult<T> = std::result::Result<T, CompilerError>;

/// Compilation context for tracking constants and symbols
#[derive(Debug)]
pub struct CompilerContext {
    /// Constant pool - values indexed by position
    pub constants: Vec<Value>,
    /// Symbol table - maps symbol names to indices
    pub symbols: HashMap<String, usize>,
    /// Generated bytecode instructions
    pub code: Vec<Instruction>,
    /// Type metadata storage for functions
    pub type_metadata: HashMap<String, SimpleFunctionSignature>,
    /// Enhanced type metadata with detailed type information
    pub enhanced_metadata: HashMap<String, EnhancedFunctionSignature>,
    /// User-defined function bodies (AST expressions)
    pub user_functions: HashMap<String, crate::ast::Expr>,
}

impl CompilerContext {
    pub fn new() -> Self {
        CompilerContext {
            constants: Vec::new(),
            symbols: HashMap::new(),
            code: Vec::new(),
            type_metadata: HashMap::new(),
            enhanced_metadata: HashMap::new(),
            user_functions: HashMap::new(),
        }
    }

    /// Add a constant to the pool, returns its index
    pub fn add_constant(&mut self, value: Value) -> CompilerResult<usize> {
        // Check for duplicates to avoid bloat
        for (i, existing) in self.constants.iter().enumerate() {
            if existing == &value {
                return Ok(i);
            }
        }

        if self.constants.len() >= 0xFFFFFF {
            return Err(CompilerError::TooManyConstants);
        }

        self.constants.push(value);
        Ok(self.constants.len() - 1)
    }

    /// Add a symbol to the table, returns its index
    pub fn add_symbol(&mut self, name: String) -> usize {
        if let Some(&index) = self.symbols.get(&name) {
            return index;
        }
        let index = self.symbols.len();
        self.symbols.insert(name, index);
        index
    }

    /// Emit an instruction
    pub fn emit(&mut self, opcode: OpCode, operand: u32) -> CompilerResult<()> {
        let instruction = Instruction::new(opcode, operand)
            .map_err(|_| CompilerError::UnsupportedExpression("Invalid instruction".to_string()))?;
        self.code.push(instruction);
        Ok(())
    }

    /// Get the current code position (for jumps)
    pub fn current_position(&self) -> usize {
        self.code.len()
    }

    /// Register a function type signature
    pub fn register_type_signature(&mut self, signature: SimpleFunctionSignature) {
        self.type_metadata.insert(signature.name.clone(), signature);
    }

    /// Get a function type signature by name
    pub fn get_type_signature(&self, name: &str) -> Option<&SimpleFunctionSignature> {
        self.type_metadata.get(name)
    }

    /// Check if a function has type metadata
    pub fn has_type_metadata(&self, name: &str) -> bool {
        self.type_metadata.contains_key(name)
    }

    /// Register an enhanced function type signature
    pub fn register_enhanced_signature(&mut self, signature: EnhancedFunctionSignature) {
        self.enhanced_metadata.insert(signature.name.clone(), signature);
    }

    /// Get an enhanced function type signature by name
    pub fn get_enhanced_type_signature(&self, name: &str) -> Option<&EnhancedFunctionSignature> {
        self.enhanced_metadata.get(name)
    }

    /// Check if a function has enhanced type metadata
    pub fn has_enhanced_metadata(&self, name: &str) -> bool {
        self.enhanced_metadata.contains_key(name)
    }
}

impl Default for CompilerContext {
    fn default() -> Self {
        Self::new()
    }
}

/// The main compiler
#[derive(Debug)]
pub struct Compiler {
    pub context: CompilerContext,
    pub stdlib: StandardLibrary,
    pub registry: FunctionRegistry,
}

impl Compiler {
    /// Create a new compiler
    pub fn new() -> Self {
        let mut registry = create_global_registry().expect("Failed to create function registry");
        
        // Initialize stdlib attributes for Phase 5A
        registry.register_stdlib_attributes();
        
        Compiler {
            context: CompilerContext::new(),
            stdlib: StandardLibrary::new(),
            registry,
        }
    }

    /// Compile an expression to bytecode
    pub fn compile_expr(&mut self, expr: &Expr) -> CompilerResult<()> {
        match expr {
            Expr::Number(Number::Integer(n)) => {
                // If there are already constants in the pool, always use constant pool for consistency
                // This prevents VM heuristic confusion between immediate values and indices
                if !self.context.constants.is_empty() || *n < 0 || *n > 0xFFFFFF {
                    // Use constant pool for consistency or if value doesn't fit in 24 bits
                    let const_index = self.context.add_constant(Value::Integer(*n))?;
                    self.context.emit(OpCode::LDC, const_index as u32)?;
                } else {
                    // Only use immediate values when constant pool is empty
                    self.context.emit(OpCode::LDC, *n as u32)?;
                }
            }
            Expr::Number(Number::Real(f)) => {
                let const_index = self.context.add_constant(Value::Real(*f))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::String(s) => {
                let const_index = self.context.add_constant(Value::String(s.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Symbol(sym) => {
                // Track symbol in symbol table
                let _symbol_index = self.context.add_symbol(sym.name.clone());
                
                // Symbols now loaded via constant pool with LDC
                let const_index = self.context.add_constant(Value::Symbol(sym.name.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::List(elements) => {
                // Compile each element and create a list
                let mut list_values = Vec::new();
                for element in elements {
                    // For now, we'll evaluate each element and add to list
                    // This is a simplified approach - a full implementation would
                    // handle this more efficiently at runtime
                    match element {
                        Expr::Number(Number::Integer(n)) => {
                            list_values.push(Value::Integer(*n));
                        }
                        Expr::Number(Number::Real(f)) => {
                            list_values.push(Value::Real(*f));
                        }
                        Expr::String(s) => {
                            list_values.push(Value::String(s.clone()));
                        }
                        Expr::Symbol(sym) => {
                            list_values.push(Value::Symbol(sym.name.clone()));
                        }
                        _ => {
                            // For complex expressions, we'd need to compile them and evaluate at runtime
                            // For now, just put the list in the constant pool
                            return Err(CompilerError::UnsupportedExpression(format!(
                                "Complex list element: {:?}",
                                element
                            )));
                        }
                    }
                }

                // Add the list to the constant pool
                let const_index = self.context.add_constant(Value::List(list_values))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Function { head, args } => {
                // Use attribute-aware compilation (Phase 5A.5.1a)
                self.compile_function_with_attributes(head, args)?;
            }
            Expr::Pattern(pattern) => {
                // Store pattern in constant pool as a Pattern value
                let const_index = self.context.add_constant(Value::Pattern(pattern.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Replace { expr, rules, repeated } => {
                // Compile replace expressions (/.  and //.)
                self.compile_replace_expression(expr, rules, *repeated)?;
            }
            Expr::Rule { lhs, rhs, delayed } => {
                // Compile rule expressions (-> and :>)
                self.compile_rule_expression(lhs, rhs, *delayed)?;
            }
            Expr::DotCall { object, method, args } => {
                self.compile_method_call(object, method, args)?;
            }
            Expr::Assignment { lhs, rhs, delayed } => {
                if *delayed {
                    self.compile_delayed_assignment(lhs, rhs)?;
                } else {
                    self.compile_immediate_assignment(lhs, rhs)?;
                }
            }
            Expr::TypedFunction { head, params, return_type } => {
                // For now, compile TypedFunction as a regular function
                // Type information will be stored in metadata for later validation
                self.compile_typed_function(head, params, return_type)?;
            }
            _ => {
                return Err(CompilerError::UnsupportedExpression(format!("{:?}", expr)));
            }
        }
        Ok(())
    }

    /// Compile a function call
    fn compile_function_call(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Check if this is a built-in arithmetic function that maps to a bytecode instruction
        if let Expr::Symbol(sym) = head {
            match sym.name.as_str() {
                "Plus" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Plus".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    // Compile arguments in order (left operand first)
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::ADD, 0)?;
                    return Ok(());
                }
                "Times" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Times".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::MUL, 0)?;
                    return Ok(());
                }
                "Divide" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Divide".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::DIV, 0)?;
                    return Ok(());
                }
                "Power" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Power".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::POW, 0)?;
                    return Ok(());
                }
                "Minus" => {
                    // Handle unary minus: Minus[x] -> 0 - x
                    if args.len() == 1 {
                        let zero_index = self.context.add_constant(Value::Integer(0))?;
                        self.context.emit(OpCode::LDC, zero_index as u32)?;
                        self.compile_expr(&args[0])?;
                        self.context.emit(OpCode::SUB, 0)?;
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Minus".to_string(),
                            expected: 1,
                            actual: args.len(),
                        });
                    }
                }
                _ => {
                    // Check if this is a stdlib function - use CallStatic for 1000x+ speedup!
                    if let Some(stdlib_index) = self.registry.get_stdlib_index(&sym.name) {
                        // Compile arguments first
                        for arg in args {
                            self.compile_expr(arg)?;
                        }

                        // Emit CallStatic with stdlib function index (32-78)
                        self.context.emit(OpCode::CallStatic, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
                        return Ok(());
                    }
                    
                    // Check if this is a user-defined function - use CallUser for type validation!
                    if self.context.has_enhanced_metadata(&sym.name) || self.context.has_type_metadata(&sym.name) {
                        // Compile arguments first
                        for arg in args {
                            self.compile_expr(arg)?;
                        }
                        
                        // Emit CallUser with function name index
                        let function_name_index = self.context.add_constant(Value::Symbol(sym.name.clone()))?;
                        self.context.emit(OpCode::CallUser, ((function_name_index as u32) << 8) | (args.len() as u32))?;
                        return Ok(());
                    }
                    
                    // Try compile-time static method resolution
                    if !args.is_empty() {
                        // Check if this method exists in any Foreign type
                        let mut method_found = false;
                        let mut expected_arity = None;
                        
                        // Check all known Foreign types for this method
                        for type_name in self.registry.get_type_names() {
                            if self.registry.has_method(&type_name, &sym.name) {
                                method_found = true;
                                // Get arity from function signature (lookup requires mutable self)
                                // For now, we'll use hardcoded common method arities
                                expected_arity = Some(match sym.name.as_str() {
                                    "Length" | "Type" | "ToList" | "IsEmpty" | "Shape" | "Columns" | "Rows" => 0,
                                    "Get" | "Append" => 1, 
                                    "Set" | "Slice" => 2,
                                    _ => args.len(), // Allow any arity for unknown methods
                                });
                                break;
                            }
                        }
                        
                        if method_found {
                            // Validate arity at compile time
                            if let Some(expected) = expected_arity {
                                if args.len() != expected {
                                    return Err(CompilerError::InvalidMethodArity {
                                        method: sym.name.clone(),
                                        expected,
                                        actual: args.len(),
                                    });
                                }
                            }
                            
                            // Compile all arguments (first arg is the object)
                            for arg in args {
                                self.compile_expr(arg)?;
                            }
                            
                            // Map method name to function index (simplified mapping)
                            let function_index = match sym.name.as_str() {
                                "Length" => 0,
                                "Type" => 1, 
                                "ToList" => 2,
                                "IsEmpty" => 3,
                                "Get" => 4,
                                "Append" => 5,
                                "Set" => 6,
                                "Slice" => 7,
                                "Shape" => 8,
                                "Columns" => 9,
                                "Rows" => 10,
                                _ => 0, // Default fallback
                            };
                            let argc = args.len() as u8;
                            
                            // Generate CallStatic instruction for static dispatch
                            let instruction = Instruction::new_call_static(function_index, argc)
                                .map_err(|_| CompilerError::TooManyConstants)?;
                            self.context.code.push(instruction);
                            return Ok(());
                        }
                    }
                    // For unknown functions with no args, fall through to error
                }
            }
        }

        // Handle unknown functions as symbolic expressions (for symbolic computation)
        // Create a symbolic function representation
        if let Expr::Symbol(sym) = head {
            // Compile arguments first
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            // Create a Function value representing the symbolic function call
            let function_repr = if args.is_empty() {
                sym.name.clone() // f becomes "f"
            } else {
                format!("{}[{}]", sym.name, "...".repeat(args.len())) // f[x,y] becomes "f[..,..]"
            };
            
            // Store the symbolic function as a Function value
            let const_index = self.context.add_constant(Value::Function(function_repr))?;
            self.context.emit(OpCode::LDC, const_index as u32)?;
            
            Ok(())
        } else {
            Err(CompilerError::UnknownFunction(format!("{:?}", head)))
        }
    }

    /// Compile a method call (obj.Method[args] syntax) using unified registry
    fn compile_method_call(&mut self, object: &Expr, method: &str, args: &[Expr]) -> CompilerResult<()> {
        // Search all known Foreign types for this method
        let mut method_found = false;
        let mut method_index = None;
        
        for type_name in self.registry.get_type_names() {
            if self.registry.has_method(&type_name, method) {
                method_found = true;
                method_index = self.registry.get_method_index(&type_name, method);
                break;
            }
        }
        
        if method_found && method_index.is_some() {
            // Compile object expression first
            self.compile_expr(object)?;
            
            // Compile arguments
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            let index = method_index.unwrap();
            // Emit CallStatic with Foreign method index (0-31)
            self.context.emit(OpCode::CallStatic, ((index as u32) << 8) | (args.len() as u32))?;
            return Ok(());
        }
        
        // Method not found in registry
        Err(CompilerError::UnknownMethod {
            type_name: "Unknown".to_string(),  // We don't know the type at compile time
            method: method.to_string(),
        })
    }

    /// Compile a complete program (list of expressions)
    pub fn compile_program(&mut self, expressions: &[Expr]) -> CompilerResult<()> {
        for expr in expressions {
            self.compile_expr(expr)?;
            // For statements, we might want to pop the result if it's not the last one
            // For now, keep all results on the stack
        }
        // No halt instruction needed - execution ends naturally
        Ok(())
    }

    /// Create a VM loaded with the compiled bytecode
    pub fn into_vm(self) -> VirtualMachine {
        let mut vm = VirtualMachine::new();
        vm.load(self.context.code, self.context.constants);

        // Copy symbol table to VM
        for (name, index) in self.context.symbols {
            vm.symbols.insert(name, index);
        }

        vm
    }

    /// Convenience method to compile and evaluate an expression
    pub fn eval(expr: &Expr) -> CompilerResult<Value> {
        let mut compiler = Compiler::new();
        compiler.compile_expr(expr)?;
        // No halt instruction needed

        let mut vm = compiler.into_vm();
        vm.run()
            .map_err(|e| CompilerError::UnsupportedExpression(format!("Runtime error: {:?}", e)))
    }
    
    // ================================
    // ATTRIBUTE PROCESSING INFRASTRUCTURE (Phase 5A.5.1a)
    // ================================
    
    /// Extract function name from the head expression of a function call
    /// 
    /// This handles simple cases like Symbol("Sin") and prepares for more complex cases
    pub fn extract_function_name(&self, head: &Expr) -> CompilerResult<String> {
        match head {
            Expr::Symbol(sym) => Ok(sym.name.clone()),
            _ => Err(CompilerError::UnsupportedExpression(format!(
                "Complex function head not yet supported: {:?}",
                head
            ))),
        }
    }
    
    /// Query function attributes from the registry
    /// 
    /// Returns the list of attributes for the given function, or empty list if none
    pub fn get_function_attributes(&self, function_name: &str) -> Vec<crate::linker::FunctionAttribute> {
        self.registry.get_function_attributes(function_name)
    }
    
    /// Check if a function has a specific attribute
    pub fn function_has_attribute(&self, function_name: &str, attribute: &crate::linker::FunctionAttribute) -> bool {
        self.registry.function_has_attribute(function_name, attribute)
    }
    
    /// Enhanced function call compilation with attribute processing
    /// 
    /// This is the new entry point that will replace direct compile_function_call usage
    /// for attribute-aware compilation
    fn compile_function_with_attributes(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Step 1: Extract function name
        let function_name = self.extract_function_name(head)?;
        
        // Step 2: Query attributes
        let attributes = self.get_function_attributes(&function_name);
        
        // Step 3: Apply attribute-specific processing (Phase 5A.5.1b-d)
        if !attributes.is_empty() {
            println!("ðŸ” Found attributes for {}: {:?}", function_name, attributes);
            
            // Phase 5A.5.1b: Process Hold attributes (highest priority)
            for attribute in &attributes {
                if let crate::linker::FunctionAttribute::Hold(positions) = attribute {
                    return self.compile_function_with_hold(head, args, positions);
                }
            }
            
            // Check if there are list arguments for Listable priority decision
            let has_list_args = args.iter().any(|arg| matches!(arg, Expr::List(_)));
            
            // Priority: If there are list arguments, Listable takes precedence over Orderless
            if has_list_args {
                // Phase 5A.5.1c: Process Listable attributes FIRST when lists are present
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Listable = attribute {
                        return self.compile_function_with_listable(head, args);
                    }
                }
                
                // Phase 5A.5.1d: Process Orderless attributes as fallback
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Orderless = attribute {
                        return self.compile_function_with_orderless(head, args);
                    }
                }
            } else {
                // Phase 5A.5.1d: Process Orderless attributes FIRST when no lists present
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Orderless = attribute {
                        return self.compile_function_with_orderless(head, args);
                    }
                }
                
                // Phase 5A.5.1c: Process Listable attributes as fallback
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Listable = attribute {
                        return self.compile_function_with_listable(head, args);
                    }
                }
            }
        }
        
        // Step 4: Fallback to existing compilation logic for now
        self.compile_function_call(head, args)
    }
    
    /// Compile function call with Hold attribute processing
    /// 
    /// Hold positions are 1-indexed (Hold[1] means hold the first argument)
    fn compile_function_with_hold(&mut self, head: &Expr, args: &[Expr], hold_positions: &[usize]) -> CompilerResult<()> {
        // Compile arguments, using LoadQuote for held positions
        for (i, arg) in args.iter().enumerate() {
            let position = i + 1; // Convert to 1-indexed
            
            if hold_positions.contains(&position) {
                // This argument should be held (not evaluated)
                // Store the AST expression as a Quote value in the constant pool
                let quote_value = crate::vm::Value::Quote(Box::new(arg.clone()));
                let const_index = self.context.add_constant(quote_value)?;
                self.context.emit(OpCode::LoadQuote, const_index as u32)?;
            } else {
                // Normal argument - compile and evaluate as usual
                self.compile_expr(arg)?;
            }
        }
        
        // Now emit the actual function call after processing Hold arguments
        // Use the normal function compilation path since arguments are already on stack
        if let Expr::Symbol(symbol) = head {
            // First check if it's a stdlib function
            if let Some(function_index) = self.registry.get_stdlib_index(&symbol.name) {
                // Emit CallStatic with proper argument count
                let argc = args.len();
                let operand = ((function_index as u32) << 8) | (argc as u32);
                self.context.emit(OpCode::CallStatic, operand)?;
                Ok(())
            } else if self.context.has_enhanced_metadata(&symbol.name) || self.context.has_type_metadata(&symbol.name) {
                // This is a user-defined function - emit CallUser
                let function_name_index = self.context.add_constant(Value::Symbol(symbol.name.clone()))?;
                let argc = args.len();
                let operand = ((function_name_index as u32) << 8) | (argc as u32);
                self.context.emit(OpCode::CallUser, operand)?;
                Ok(())
            } else {
                Err(CompilerError::UnknownFunction(symbol.name.clone()))
            }
        } else {
            Err(CompilerError::UnsupportedExpression("Expected symbol for function head".to_string()))
        }
    }
    
    /// Compile function call with Listable attribute processing
    /// 
    /// Listable functions automatically thread over lists:
    /// - Sin[{1,2,3}] â†’ {Sin[1], Sin[2], Sin[3]}
    /// - Plus[{1,2}, {3,4}] â†’ {Plus[1,3], Plus[2,4]}
    /// - Plus[{1,2}, 10] â†’ {Plus[1,10], Plus[2,10]}
    fn compile_function_with_listable(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Step 1: Check if any arguments are lists
        let mut has_list_args = false;
        for arg in args {
            if matches!(arg, Expr::List(_)) {
                has_list_args = true;
                break;
            }
        }
        
        // Step 2: If no list arguments, use normal CallStatic compilation
        if !has_list_args {
            return self.compile_function_call(head, args);
        }
        
        // Step 3: List arguments found - use MAP_CallStatic for list threading
        // First, extract function name and determine if it's stdlib or Foreign method
        let function_name = self.extract_function_name(head)?;
        
        // Step 3a: Handle special arithmetic functions (Plus, Times, etc.)
        // These are compiled to opcodes normally, but for Listable with lists we need special handling
        match function_name.as_str() {
            "Plus" | "Times" | "Divide" | "Power" | "Minus" => {
                // For arithmetic functions with lists, we need to find the equivalent stdlib function
                // or handle them specially. For now, let's try to find them in stdlib.
                
                // Check if this arithmetic function is registered in stdlib
                if let Some(stdlib_index) = self.registry.get_stdlib_index(&function_name) {
                    // Compile arguments normally (lists will be evaluated as list values)
                    for arg in args {
                        self.compile_expr(arg)?;
                    }
                    
                    // Emit MapCallStatic with stdlib function index
                    self.context.emit(OpCode::MapCallStatic, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
                    return Ok(());
                } else {
                    // Arithmetic function not found in stdlib registry
                    // This means we need to fall back to existing arithmetic compilation
                    // but that won't work with lists. For now, return an error.
                    return Err(CompilerError::UnknownFunction(format!(
                        "Arithmetic function {} with Listable attribute and list arguments needs stdlib registration", 
                        function_name
                    )));
                }
            }
            _ => {
                // Not a special arithmetic function, proceed with normal processing
            }
        }
        
        // Check if this is a stdlib function
        if let Some(stdlib_index) = self.registry.get_stdlib_index(&function_name) {
            // Compile arguments normally (lists will be evaluated as list values)
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            // Emit MapCallStatic with stdlib function index (32+)
            self.context.emit(OpCode::MapCallStatic, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
            return Ok(());
        }
        
        // Check if this is a method call that should be compiled as static method call
        if !args.is_empty() {
            // Check if this method exists in any Foreign type 
            for type_name in self.registry.get_type_names() {
                if self.registry.has_method(&type_name, &function_name) {
                    // Compile all arguments (first arg is the object)
                    for arg in args {
                        self.compile_expr(arg)?;
                    }
                    
                    // Map method name to function index (same mapping as in existing code)
                    let function_index = match function_name.as_str() {
                        "Length" => 0, "Type" => 1, "ToList" => 2, "IsEmpty" => 3,
                        "Get" => 4, "Append" => 5, "Set" => 6, "Slice" => 7,
                        "Shape" => 8, "Columns" => 9, "Rows" => 10,
                        _ => 0, // Default fallback
                    };
                    
                    // Generate MapCallStatic instruction for static dispatch with list threading
                    self.context.emit(OpCode::MapCallStatic, ((function_index as u32) << 8) | (args.len() as u32))?;
                    return Ok(());
                }
            }
        }
        
        // Function not found in registry - this should not happen for registered Listable functions
        Err(CompilerError::UnknownFunction(format!("Listable function {} not found in registry", function_name)))
    }
    
    /// Compile function call with Orderless attribute processing
    /// 
    /// Orderless functions have their arguments sorted in canonical order:
    /// - Numbers: sorted numerically (1, 2, 3)
    /// - Symbols: sorted alphabetically (a, b, c)
    /// - Complex expressions: sorted by a canonical ordering system
    fn compile_function_with_orderless(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Step 1: Sort arguments according to canonical order
        let mut sorted_args = args.to_vec();
        sorted_args.sort_by(|a, b| self.canonical_order(a, b));
        
        // Step 2: Handle special cases for arithmetic functions with Orderless
        if let Expr::Symbol(sym) = head {
            match sym.name.as_str() {
                "Plus" => {
                    // For Orderless Plus with multiple arguments, we need to compile them 
                    // as a sequence of binary additions: Plus[a, b, c] -> Plus[Plus[a, b], c]
                    if sorted_args.len() >= 2 {
                        // Compile first argument
                        self.compile_expr(&sorted_args[0])?;
                        
                        // Add each subsequent argument with binary Plus
                        for arg in &sorted_args[1..] {
                            self.compile_expr(arg)?;
                            self.context.emit(OpCode::ADD, 0)?;
                        }
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Plus".to_string(),
                            expected: 2,
                            actual: sorted_args.len(),
                        });
                    }
                }
                "Times" => {
                    // Similar handling for Times
                    if sorted_args.len() >= 2 {
                        self.compile_expr(&sorted_args[0])?;
                        for arg in &sorted_args[1..] {
                            self.compile_expr(arg)?;
                            self.context.emit(OpCode::MUL, 0)?;
                        }
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Times".to_string(),
                            expected: 2,
                            actual: sorted_args.len(),
                        });
                    }
                }
                _ => {
                    // For other functions, check if it's a stdlib function and handle accordingly
                    if let Some(stdlib_index) = self.registry.get_stdlib_index(&sym.name) {
                        // Compile sorted arguments normally
                        for arg in &sorted_args {
                            self.compile_expr(arg)?;
                        }
                        
                        // Emit CallStatic with stdlib function index
                        self.context.emit(OpCode::CallStatic, ((stdlib_index as u32) << 8) | (sorted_args.len() as u32))?;
                        return Ok(());
                    }
                }
            }
        }
        
        // Step 3: Fallback to normal function compilation for non-arithmetic functions
        self.compile_function_call(head, &sorted_args)
    }
    
    /// Canonical ordering for expressions (implements Mathematica-like ordering)
    /// 
    /// Ordering rules:
    /// 1. Numbers come before symbols
    /// 2. Symbols come before function calls
    /// 3. Numbers are sorted numerically
    /// 4. Symbols are sorted alphabetically
    /// 5. Function calls are sorted by head name, then by arguments
    fn canonical_order(&self, a: &Expr, b: &Expr) -> std::cmp::Ordering {
        use std::cmp::Ordering;
        use crate::ast::{Expr, Number};
        
        match (a, b) {
            // Numbers vs Numbers: sort numerically
            (Expr::Number(Number::Integer(x)), Expr::Number(Number::Integer(y))) => x.cmp(y),
            (Expr::Number(Number::Real(x)), Expr::Number(Number::Real(y))) => {
                x.partial_cmp(y).unwrap_or(Ordering::Equal)
            }
            (Expr::Number(Number::Integer(x)), Expr::Number(Number::Real(y))) => {
                (*x as f64).partial_cmp(y).unwrap_or(Ordering::Equal)
            }
            (Expr::Number(Number::Real(x)), Expr::Number(Number::Integer(y))) => {
                x.partial_cmp(&(*y as f64)).unwrap_or(Ordering::Equal)
            }
            
            // Numbers vs anything else: numbers come first
            (Expr::Number(_), _) => Ordering::Less,
            (_, Expr::Number(_)) => Ordering::Greater,
            
            // Symbols vs Symbols: sort alphabetically
            (Expr::Symbol(sym_a), Expr::Symbol(sym_b)) => sym_a.name.cmp(&sym_b.name),
            
            // Symbols vs anything else (except numbers): symbols come first
            (Expr::Symbol(_), _) => Ordering::Less,
            (_, Expr::Symbol(_)) => Ordering::Greater,
            
            // Functions vs Functions: sort by head name, then by arguments
            (Expr::Function { head: head_a, args: args_a }, Expr::Function { head: head_b, args: args_b }) => {
                // First compare the function heads
                let head_cmp = self.canonical_order(head_a, head_b);
                if head_cmp != Ordering::Equal {
                    return head_cmp;
                }
                
                // Then compare argument count
                let arity_cmp = args_a.len().cmp(&args_b.len());
                if arity_cmp != Ordering::Equal {
                    return arity_cmp;
                }
                
                // Finally compare arguments pairwise
                for (arg_a, arg_b) in args_a.iter().zip(args_b.iter()) {
                    let arg_cmp = self.canonical_order(arg_a, arg_b);
                    if arg_cmp != Ordering::Equal {
                        return arg_cmp;
                    }
                }
                
                Ordering::Equal
            }
            
            // Strings vs Strings: sort alphabetically
            (Expr::String(s_a), Expr::String(s_b)) => s_a.cmp(s_b),
            
            // Default cases - maintain some consistent ordering for other expression types
            // Lists come after symbols but before functions
            (Expr::List(_), Expr::Function { .. }) => Ordering::Less,
            (Expr::Function { .. }, Expr::List(_)) => Ordering::Greater,
            (Expr::List(_), _) => Ordering::Greater,
            (_, Expr::List(_)) => Ordering::Less,
            
            // Strings come after symbols but before functions
            (Expr::String(_), Expr::Function { .. }) => Ordering::Less,
            (Expr::Function { .. }, Expr::String(_)) => Ordering::Greater,
            
            // For any other cases, use a consistent default
            _ => Ordering::Equal,
        }
    }

    /// Compile replace expressions (expr /. rules and expr //. rules)
    fn compile_replace_expression(&mut self, expr: &Expr, rules: &Expr, repeated: bool) -> CompilerResult<()> {
        // Compile the expression to be transformed
        self.compile_expr(expr)?;
        
        // Compile the rules
        self.compile_expr(rules)?;
        
        // For now, call the ReplaceAll stdlib function
        // Later we might want ReplaceRepeated for the //. case
        let function_name = if repeated { "ReplaceRepeated" } else { "ReplaceAll" };
        
        if let Some(stdlib_index) = self.registry.get_stdlib_index(function_name) {
            // Emit CallStatic with stdlib function index
            self.context.emit(OpCode::CallStatic, ((stdlib_index as u32) << 8) | 2)?;
            Ok(())
        } else {
            Err(CompilerError::UnknownFunction(format!(
                "Replace function {} not found in stdlib", function_name
            )))
        }
    }

    /// Compile rule expressions (lhs -> rhs and lhs :> rhs)
    fn compile_rule_expression(&mut self, lhs: &Expr, rhs: &Expr, delayed: bool) -> CompilerResult<()> {
        // For now, create a function representation of the rule
        // This is similar to how the stdlib Rule function works
        let rule_type = if delayed { "RuleDelayed" } else { "Rule" };
        let rule_repr = format!("{}[{:?}, {:?}]", rule_type, lhs, rhs);
        
        // Store the rule as a Function value in constants
        let const_index = self.context.add_constant(Value::Function(rule_repr))?;
        self.context.emit(OpCode::LDC, const_index as u32)?;
        
        Ok(())
    }

    /// Compile immediate assignment (=)
    fn compile_immediate_assignment(&mut self, lhs: &Expr, rhs: &Expr) -> CompilerResult<()> {
        match lhs {
            // Simple variable assignment: x = value
            Expr::Symbol(sym) => {
                // Compile the right-hand side expression first
                self.compile_expr(rhs)?;
                
                // Store the symbol name in constants and get its index
                let symbol_const_index = self.context.add_constant(Value::Symbol(sym.name.clone()))?;
                
                // Emit STS instruction to store the value
                self.context.emit(OpCode::STS, symbol_const_index as u32)?;
                
                Ok(())
            }
            
            // Typed function assignment: f[x: Integer]: Integer = x + 1
            Expr::TypedFunction { head, params, return_type } => {
                // Extract function name from head
                if let Expr::Symbol(func_symbol) = head.as_ref() {
                    // Store type information in enhanced metadata
                    self.store_typed_function_metadata(&func_symbol.name, params, return_type)?;
                    
                    // Store the function body AST for later execution (instead of compiling)
                    self.context.user_functions.insert(func_symbol.name.clone(), rhs.clone());
                    
                    // For now, just emit a placeholder constant to maintain the instruction flow
                    let placeholder_index = self.context.add_constant(Value::Integer(0))?;
                    self.context.emit(OpCode::LDC, placeholder_index as u32)?;
                    
                    // Store the function in global symbols
                    let symbol_const_index = self.context.add_constant(Value::Symbol(func_symbol.name.clone()))?;
                    self.context.emit(OpCode::STS, symbol_const_index as u32)?;
                    
                    Ok(())
                } else {
                    Err(CompilerError::UnsupportedExpression(format!(
                        "TypedFunction head must be a symbol, found: {:?}", 
                        head
                    )))
                }
            }
            
            // Function assignment with mixed parameters: f[x: Integer, y] = value
            Expr::Function { head, args } => {
                // Extract function name from head
                if let Expr::Symbol(func_symbol) = head.as_ref() {
                    // Store type information for mixed function (some typed, some untyped parameters)
                    self.store_function_metadata(&func_symbol.name, args)?;
                    
                    // Store the function body AST for later execution (instead of compiling)
                    self.context.user_functions.insert(func_symbol.name.clone(), rhs.clone());
                    
                    // Emit a placeholder constant to maintain the instruction flow
                    let placeholder_index = self.context.add_constant(Value::Integer(0))?;
                    self.context.emit(OpCode::LDC, placeholder_index as u32)?;
                    
                    // Store the function in global symbols
                    let symbol_const_index = self.context.add_constant(Value::Symbol(func_symbol.name.clone()))?;
                    self.context.emit(OpCode::STS, symbol_const_index as u32)?;
                    
                    Ok(())
                } else {
                    Err(CompilerError::UnsupportedExpression(format!(
                        "Function head must be a symbol, found: {:?}", 
                        head
                    )))
                }
            }
            
            _ => {
                Err(CompilerError::UnsupportedExpression(format!(
                    "Complex assignment patterns not yet supported: {:?}", 
                    lhs
                )))
            }
        }
    }

    /// Compile delayed assignment (:=)
    fn compile_delayed_assignment(&mut self, lhs: &Expr, rhs: &Expr) -> CompilerResult<()> {
        // For now, only support simple symbol assignments like x := value
        if let Expr::Symbol(sym) = lhs {
            // Store the right-hand side expression as a quoted value (unevaluated)
            let quote_const_index = self.context.add_constant(Value::Quote(Box::new(rhs.clone())))?;
            
            // Load the quoted expression onto the stack
            self.context.emit(OpCode::LDC, quote_const_index as u32)?;
            
            // Store the symbol name in constants and get its index
            let symbol_const_index = self.context.add_constant(Value::Symbol(sym.name.clone()))?;
            
            // Emit STSD instruction to store the delayed expression
            self.context.emit(OpCode::STSD, symbol_const_index as u32)?;
            
            Ok(())
        } else {
            Err(CompilerError::UnsupportedExpression(format!(
                "Complex delayed assignment patterns not yet supported: {:?}", 
                lhs
            )))
        }
    }

    /// Compile a typed function expression
    /// 
    /// TypedFunction expressions contain type information for parameters and return type.
    /// For now, we compile them as regular functions but store the type metadata.
    fn compile_typed_function(&mut self, head: &Expr, params: &[Expr], return_type: &Expr) -> CompilerResult<()> {
        // Extract function name for type metadata storage
        let function_name = match head {
            Expr::Symbol(sym) => sym.name.clone(),
            _ => {
                // For complex head expressions, we'll skip type metadata extraction for now
                return self.compile_function_call(head, params);
            }
        };

        // Create simple function signature
        let signature = SimpleFunctionSignature {
            name: function_name.clone(),
            param_count: params.len(),
            is_typed: true, // This came from a TypedFunction expression
        };
        
        // Store the type signature
        self.context.register_type_signature(signature);

        // Extract type information for enhanced signature
        let mut enhanced_params = Vec::new();
        let mut is_fully_typed = true;

        for param in params {
            let (param_name, param_type) = match param {
                Expr::Pattern(Pattern::Typed { name, type_pattern }) => {
                    let type_str = self.extract_type_from_expr(type_pattern);
                    (name.clone(), type_str)
                }
                Expr::Symbol(sym) => {
                    // Untyped parameter - just a symbol
                    is_fully_typed = false;
                    (sym.name.clone(), None)
                }
                _ => {
                    // Other parameter types - treat as untyped for now
                    is_fully_typed = false;
                    ("unknown".to_string(), None)
                }
            };
            enhanced_params.push((param_name, param_type));
        }

        // Extract return type
        let return_type_str = self.extract_type_from_expr(return_type);

        // Create enhanced function signature
        let enhanced_signature = EnhancedFunctionSignature {
            name: function_name.clone(),
            params: enhanced_params,
            return_type: return_type_str,
            is_typed: is_fully_typed,
            location: Some((0, 0)), // TODO: Add actual location tracking
        };

        // Store the enhanced signature
        self.context.register_enhanced_signature(enhanced_signature);
        
        // Compile as a regular function call
        self.compile_function_call(head, params)
    }

    /// Store type metadata for a typed function assignment
    fn store_typed_function_metadata(&mut self, function_name: &str, params: &[Expr], return_type: &Expr) -> CompilerResult<()> {
        // Create simple function signature
        let signature = SimpleFunctionSignature {
            name: function_name.to_string(),
            param_count: params.len(),
            is_typed: true, // This came from a TypedFunction expression
        };
        
        // Store the type signature
        self.context.register_type_signature(signature);

        // Extract type information for enhanced signature
        let mut enhanced_params = Vec::new();
        let mut is_fully_typed = true;

        for param in params {
            let (param_name, param_type) = match param {
                Expr::Pattern(Pattern::Typed { name, type_pattern }) => {
                    let type_str = self.extract_type_from_expr(type_pattern);
                    (name.clone(), type_str)
                }
                Expr::Symbol(sym) => {
                    // Untyped parameter - just a symbol
                    is_fully_typed = false;
                    (sym.name.clone(), None)
                }
                _ => {
                    // Other parameter types - treat as untyped for now
                    is_fully_typed = false;
                    ("unknown".to_string(), None)
                }
            };
            enhanced_params.push((param_name, param_type));
        }

        // Extract return type
        let return_type_str = self.extract_type_from_expr(return_type);

        // Create enhanced function signature
        let enhanced_signature = EnhancedFunctionSignature {
            name: function_name.to_string(),
            params: enhanced_params,
            return_type: return_type_str,
            is_typed: is_fully_typed,
            location: Some((0, 0)), // TODO: Add actual location tracking
        };

        // Store the enhanced signature
        self.context.register_enhanced_signature(enhanced_signature);
        
        Ok(())
    }

    /// Store metadata for a function assignment (untyped or mixed typed/untyped)
    fn store_function_metadata(&mut self, function_name: &str, args: &[Expr]) -> CompilerResult<()> {
        // Create simple function signature
        let signature = SimpleFunctionSignature {
            name: function_name.to_string(),
            param_count: args.len(),
            is_typed: false, // Regular Function expressions are considered untyped
        };
        
        // Store the type signature
        self.context.register_type_signature(signature);

        // Extract type information for enhanced signature
        let mut enhanced_params = Vec::new();
        let mut is_fully_typed = true;

        for arg in args {
            let (param_name, param_type) = match arg {
                Expr::Pattern(Pattern::Typed { name, type_pattern }) => {
                    let type_str = self.extract_type_from_expr(type_pattern);
                    (name.clone(), type_str)
                }
                Expr::Symbol(sym) => {
                    // Untyped parameter - just a symbol
                    is_fully_typed = false;
                    (sym.name.clone(), None)
                }
                _ => {
                    // Other parameter types - treat as untyped for now
                    is_fully_typed = false;
                    ("unknown".to_string(), None)
                }
            };
            enhanced_params.push((param_name, param_type));
        }

        // No return type for Function expressions (unlike TypedFunction)
        let return_type_str = None;

        // Create enhanced function signature
        let enhanced_signature = EnhancedFunctionSignature {
            name: function_name.to_string(),
            params: enhanced_params,
            return_type: return_type_str,
            is_typed: is_fully_typed,
            location: Some((0, 0)), // TODO: Add actual location tracking
        };

        // Store the enhanced signature
        self.context.register_enhanced_signature(enhanced_signature);
        
        Ok(())
    }

    /// Validate function call against stored type metadata
    pub fn validate_function_call(&self, function_name: &str, arg_count: usize) -> CompilerResult<()> {
        if let Some(signature) = self.context.get_type_signature(function_name) {
            if signature.param_count != arg_count {
                return Err(CompilerError::InvalidArity {
                    function: function_name.to_string(),
                    expected: signature.param_count,
                    actual: arg_count,
                });
            }
        }
        Ok(())
    }

    /// Register a type signature (convenience method)
    pub fn register_type_signature(&mut self, signature: SimpleFunctionSignature) {
        self.context.register_type_signature(signature);
    }

    /// Get type metadata statistics
    pub fn type_metadata_stats(&self) -> String {
        let total = self.context.type_metadata.len();
        let typed = self.context.type_metadata.values().filter(|sig| sig.is_typed).count();
        let untyped = total - typed;
        
        format!(
            "Type Registry Stats: {} functions ({} typed, {} untyped)",
            total, typed, untyped
        )
    }

    /// Extract type information from an expression
    pub fn extract_type_from_expr(&self, expr: &Expr) -> Option<String> {
        match expr {
            Expr::Symbol(sym) => {
                // Basic type symbols
                match sym.name.as_str() {
                    "Integer" | "Real" | "String" | "Boolean" | "Complex" | "Rational" => {
                        Some(sym.name.clone())
                    }
                    _ => Some(sym.name.clone()), // Custom types
                }
            }
            Expr::Function { head, args } => {
                // Handle complex types like List[Integer], Map[String, Integer], etc.
                if let Expr::Symbol(head_sym) = head.as_ref() {
                    match head_sym.name.as_str() {
                        "List" if args.len() == 1 => {
                            if let Some(elem_type) = self.extract_type_from_expr(&args[0]) {
                                Some(format!("List[{}]", elem_type))
                            } else {
                                Some("List".to_string())
                            }
                        }
                        "Map" if args.len() == 2 => {
                            let key_type = self.extract_type_from_expr(&args[0]);
                            let value_type = self.extract_type_from_expr(&args[1]);
                            if let (Some(k_ty), Some(v_ty)) = (key_type, value_type) {
                                Some(format!("Map[{}, {}]", k_ty, v_ty))
                            } else {
                                Some("Map".to_string())
                            }
                        }
                        "Tuple" if args.len() >= 1 => {
                            let elem_types: Vec<String> = args
                                .iter()
                                .filter_map(|arg| self.extract_type_from_expr(arg))
                                .collect();
                            if elem_types.len() == args.len() {
                                Some(format!("Tuple[{}]", elem_types.join(", ")))
                            } else {
                                Some("Tuple".to_string())
                            }
                        }
                        "Optional" if args.len() == 1 => {
                            if let Some(inner_type) = self.extract_type_from_expr(&args[0]) {
                                Some(format!("Optional[{}]", inner_type))
                            } else {
                                Some("Optional".to_string())
                            }
                        }
                        "Union" if args.len() >= 2 => {
                            let union_types: Vec<String> = args
                                .iter()
                                .filter_map(|arg| self.extract_type_from_expr(arg))
                                .collect();
                            if union_types.len() == args.len() {
                                Some(format!("Union[{}]", union_types.join(", ")))
                            } else {
                                Some("Union".to_string())
                            }
                        }
                        "Array" if args.len() == 2 => {
                            let elem_type = self.extract_type_from_expr(&args[0]);
                            // For Array[Real, 3], the second arg should be a number
                            let size_str = match &args[1] {
                                Expr::Number(Number::Integer(n)) => Some(n.to_string()),
                                Expr::Symbol(sym) => Some(sym.name.clone()), // Could be a variable
                                _ => None,
                            };
                            if let (Some(e_ty), Some(s)) = (elem_type, size_str) {
                                Some(format!("Array[{}, {}]", e_ty, s))
                            } else {
                                Some("Array".to_string())
                            }
                        }
                        "Function" if args.len() >= 2 => {
                            let param_types: Vec<String> = args[..args.len()-1]
                                .iter()
                                .filter_map(|arg| self.extract_type_from_expr(arg))
                                .collect();
                            let return_type = self.extract_type_from_expr(&args[args.len()-1]);
                            
                            if let Some(ret_ty) = return_type {
                                Some(format!("Function[{}, {}]", param_types.join(", "), ret_ty))
                            } else {
                                Some("Function".to_string())
                            }
                        }
                        "Result" if args.len() == 1 => {
                            // Handle Result[T] type
                            if let Some(ok_type) = self.extract_type_from_expr(&args[0]) {
                                Some(format!("Result[{}]", ok_type))
                            } else {
                                Some("Result".to_string())
                            }
                        }
                        "Config" | "Data" => {
                            // Handle custom types like Config, Data - these might have no args
                            Some(head_sym.name.clone())
                        }
                        _ => Some(head_sym.name.clone()),
                    }
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    /// Register an enhanced type signature (convenience method)
    pub fn register_enhanced_signature(&mut self, signature: EnhancedFunctionSignature) {
        self.context.register_enhanced_signature(signature);
    }

    /// Infer the type of an expression based on its structure and context
    pub fn infer_expression_type(&self, expr: &Expr) -> Option<String> {
        match expr {
            // Literal types
            Expr::Number(Number::Integer(_)) => Some("Integer".to_string()),
            Expr::Number(Number::Real(_)) => Some("Real".to_string()),
            Expr::String(_) => Some("String".to_string()),
            
            // List types
            Expr::List(items) => {
                if items.is_empty() {
                    Some("List".to_string())
                } else {
                    // Infer types of all elements
                    let element_types: Vec<String> = items
                        .iter()
                        .filter_map(|item| self.infer_expression_type(item))
                        .collect();
                    
                    if element_types.is_empty() {
                        Some("List".to_string())
                    } else {
                        // Check if all elements have the same type
                        let first_type = &element_types[0];
                        if element_types.iter().all(|t| t == first_type) {
                            Some(format!("List[{}]", first_type))
                        } else {
                            // Handle type coercion: Integer can be promoted to Real
                            let has_integers = element_types.iter().any(|t| t == "Integer");
                            let has_reals = element_types.iter().any(|t| t == "Real");
                            let has_others = element_types.iter().any(|t| t != "Integer" && t != "Real");
                            
                            if !has_others && (has_integers || has_reals) {
                                // Only Integer and Real types - promote to Real
                                Some("List[Real]".to_string())
                            } else {
                                // Multiple different types - create union type
                                let unique_types: HashSet<_> = element_types.into_iter().collect();
                                let mut sorted_types: Vec<_> = unique_types.into_iter().collect();
                                sorted_types.sort(); // For consistent output
                                Some(format!("List[Union[{}]]", sorted_types.join(", ")))
                            }
                        }
                    }
                }
            }
            
            // Function calls
            Expr::Function { head, args } => {
                if let Expr::Symbol(head_sym) = head.as_ref() {
                    match head_sym.name.as_str() {
                        // Arithmetic operations
                        "Plus" | "Times" | "Minus" => {
                            // Infer result type from operand types
                            let arg_types: Vec<String> = args
                                .iter()
                                .filter_map(|arg| self.infer_expression_type(arg))
                                .collect();
                            
                            // Type promotion rules: Integer + Integer = Integer, otherwise Real
                            if arg_types.iter().all(|t| t == "Integer") {
                                Some("Integer".to_string())
                            } else if arg_types.iter().all(|t| t == "Integer" || t == "Real") {
                                Some("Real".to_string())
                            } else {
                                None // Cannot infer type for non-numeric operations
                            }
                        }
                        "Divide" => {
                            // Division always returns Real
                            Some("Real".to_string())
                        }
                        "Power" => {
                            // Power can return Integer or Real depending on exponent
                            if args.len() == 2 {
                                if let Some(exp_type) = self.infer_expression_type(&args[1]) {
                                    if exp_type == "Integer" {
                                        // Check if exponent is positive
                                        Some("Real".to_string()) // For safety, always return Real
                                    } else {
                                        Some("Real".to_string())
                                    }
                                } else {
                                    Some("Real".to_string())
                                }
                            } else {
                                Some("Real".to_string())
                            }
                        }
                        _ => {
                            // Check if this is a registered typed function
                            if let Some(signature) = self.context.get_enhanced_type_signature(&head_sym.name) {
                                signature.return_type.clone()
                            } else {
                                None
                            }
                        }
                    }
                } else {
                    None
                }
            }
            
            // Symbol references (variables, type names, etc.)
            Expr::Symbol(sym) => {
                // Could be a variable or type name - for now, we can't infer without context
                None
            }
            
            _ => None,
        }
    }

    /// Compile an expression with type checking enabled
    pub fn compile_expr_with_type_checking(&mut self, expr: &Expr) -> CompilerResult<()> {
        match expr {
            // Function calls - perform type checking
            Expr::Function { head, args } => {
                if let Expr::Symbol(head_sym) = head.as_ref() {
                    // Check if this is a registered typed function
                    if let Some(signature) = self.context.get_enhanced_type_signature(&head_sym.name) {
                        // Validate arity
                        if signature.param_count() != args.len() {
                            return Err(CompilerError::InvalidArity {
                                function: head_sym.name.clone(),
                                expected: signature.param_count(),
                                actual: args.len(),
                            });
                        }
                        
                        // Validate argument types if function is typed
                        if signature.is_typed {
                            for (i, arg) in args.iter().enumerate() {
                                if let Some(inferred_type) = self.infer_expression_type(arg) {
                                    if let Some((_, expected_type)) = signature.params.get(i) {
                                        if let Some(expected) = expected_type {
                                            if !self.is_type_compatible(&inferred_type, expected) {
                                                let param_name = &signature.params[i].0;
                                                return Err(CompilerError::UnsupportedExpression(format!(
                                                    "Type mismatch for parameter '{}': expected {}, got {}",
                                                    param_name, expected, inferred_type
                                                )));
                                            }
                                        }
                                    }
                                } else {
                                    // Cannot infer argument type - might be a variable or complex expression
                                    // For now, we'll allow it but could add stricter checking later
                                }
                            }
                        }
                    } else {
                        // Check for built-in arithmetic operations
                        match head_sym.name.as_str() {
                            "Plus" | "Times" | "Minus" | "Divide" => {
                                // Validate that all arguments are numeric
                                for arg in args {
                                    if let Some(arg_type) = self.infer_expression_type(arg) {
                                        if arg_type != "Integer" && arg_type != "Real" {
                                            return Err(CompilerError::UnsupportedExpression(format!(
                                                "Cannot perform arithmetic operation on type: {}",
                                                arg_type
                                            )));
                                        }
                                    }
                                }
                            }
                            _ => {
                                // Unknown function - continue with regular compilation
                            }
                        }
                    }
                }
                // Continue with regular compilation
                self.compile_expr(expr)
            }
            
            // Assignment expressions - check type compatibility
            Expr::Assignment { lhs, rhs, delayed: _ } => {
                // For now, we'll implement basic assignment type checking
                // This would need a variable type context in a full implementation
                if let Some(rhs_type) = self.infer_expression_type(rhs) {
                    // In a full implementation, we'd check against lhs variable type
                    // For now, just ensure the RHS has a valid type
                    self.compile_expr(expr)
                } else {
                    self.compile_expr(expr)
                }
            }
            
            // For other expressions, use regular compilation
            _ => self.compile_expr(expr)
        }
    }
    
    /// Check if a type is compatible with an expected type (including coercion rules)
    fn is_type_compatible(&self, actual: &str, expected: &str) -> bool {
        if actual == expected {
            return true;
        }
        
        // Type coercion rules
        match (actual, expected) {
            // Integer can be coerced to Real
            ("Integer", "Real") => true,
            
            // List type compatibility - check element types
            (actual, expected) if actual.starts_with("List[") && expected.starts_with("List[") => {
                if let (Some(actual_elem), Some(expected_elem)) = (
                    self.extract_list_element_type(actual),
                    self.extract_list_element_type(expected)
                ) {
                    self.is_type_compatible(&actual_elem, &expected_elem)
                } else {
                    false
                }
            }
            
            // More coercion rules can be added here
            _ => false,
        }
    }
    
    /// Extract element type from List[T] type string
    fn extract_list_element_type(&self, list_type: &str) -> Option<String> {
        if list_type.starts_with("List[") && list_type.ends_with(']') {
            let element_type = &list_type[5..list_type.len()-1];
            Some(element_type.to_string())
        } else {
            None
        }
    }

    /// Validate function call with type information
    pub fn validate_enhanced_function_call(
        &self,
        function_name: &str,
        arg_count: usize,
        arg_types: &[&str],
    ) -> CompilerResult<()> {
        if let Some(signature) = self.context.get_enhanced_type_signature(function_name) {
            // Check arity
            if signature.param_count() != arg_count {
                return Err(CompilerError::InvalidArity {
                    function: function_name.to_string(),
                    expected: signature.param_count(),
                    actual: arg_count,
                });
            }

            // Check types if the function is typed
            if signature.is_typed {
                for (i, (param_name, expected_type)) in signature.params.iter().enumerate() {
                    if let Some(expected) = expected_type {
                        if i < arg_types.len() {
                            let actual = arg_types[i];
                            if expected != actual {
                                return Err(CompilerError::UnsupportedExpression(format!(
                                    "Type mismatch for parameter '{}': expected {}, got {}",
                                    param_name, expected, actual
                                )));
                            }
                        }
                    }
                }
            }
        }
        Ok(())
    }
}

impl Default for Compiler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::{Expr, Number, Symbol};

    #[test]
    fn test_compile_integer_small() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(42));

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 42);
    }

    #[test]
    fn test_compile_integer_large() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(0x1000000)); // Larger than 24-bit

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Integer(0x1000000));
    }

    #[test]
    fn test_compile_real() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Real(3.14));

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Real(3.14));
    }

    #[test]
    fn test_compile_string() {
        let mut compiler = Compiler::new();
        let expr = Expr::String("hello".to_string());

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(
            compiler.context.constants[0],
            Value::String("hello".to_string())
        );
    }

    #[test]
    fn test_compile_symbol() {
        let mut compiler = Compiler::new();
        let expr = Expr::Symbol(Symbol {
            name: "x".to_string(),
        });

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.symbols.len(), 1);
        assert_eq!(compiler.context.symbols["x"], 0);
    }

    #[test]
    fn test_compile_plus() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 2, Push 3, Add
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::ADD);
    }

    #[test]
    fn test_compile_times() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(4)),
                Expr::Number(Number::Integer(5)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 4, Push 5, Mul
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 4);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 5);
        assert_eq!(compiler.context.code[2].opcode, OpCode::MUL);
    }

    #[test]
    fn test_compile_nested_arithmetic() {
        let mut compiler = Compiler::new();
        // (2 + 3) * 4 -> Times[Plus[2, 3], 4]
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol {
                        name: "Plus".to_string(),
                    })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Current compilation order: Times[Plus[2,3], 4] compiles as:
        // 1. LDC 4 (Times arg[1])
        // 2. LDC 2 (Plus arg[0]) 
        // 3. LDC 3 (Plus arg[1])
        // 4. ADD (Plus operation)
        // 5. MUL (Times operation)
        // Note: This order is suboptimal for stack-based VM but matches current implementation
        assert_eq!(compiler.context.code.len(), 5);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 4); // Times arg[1] compiled first
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 2); // Plus arg[0]
        assert_eq!(compiler.context.code[2].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[2].operand, 3); // Plus arg[1]
        assert_eq!(compiler.context.code[3].opcode, OpCode::ADD);
        assert_eq!(compiler.context.code[4].opcode, OpCode::MUL);
    }

    #[test]
    fn test_invalid_arity() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![Expr::Number(Number::Integer(1))], // Only one argument
        };

        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::InvalidArity {
                function,
                expected,
                actual,
            } => {
                assert_eq!(function, "Plus");
                assert_eq!(expected, 2);
                assert_eq!(actual, 1);
            }
            _ => panic!("Expected InvalidArity error"),
        }
    }

    #[test]
    fn test_unknown_function() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "UnknownFunc".to_string(),
            })),
            args: vec![],
        };

        // Unknown functions are now treated as symbolic expressions, not errors
        let result = compiler.compile_expr(&expr);
        assert!(result.is_ok());
        
        // Should generate: LDC instruction to load symbolic function
        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        
        // Should have created a symbolic Function value in constants
        assert_eq!(compiler.context.constants.len(), 1);
        match &compiler.context.constants[0] {
            Value::Function(name) => assert_eq!(name, "UnknownFunc"),
            _ => panic!("Expected Function value in constants"),
        }
    }

    #[test]
    fn test_constant_deduplication() {
        let mut compiler = Compiler::new();

        // Add the same constant twice
        let index1 = compiler.context.add_constant(Value::Integer(42)).unwrap();
        let index2 = compiler.context.add_constant(Value::Integer(42)).unwrap();

        assert_eq!(index1, index2);
        assert_eq!(compiler.context.constants.len(), 1);
    }

    #[test]
    fn test_symbol_deduplication() {
        let mut compiler = Compiler::new();

        // Add the same symbol twice
        let index1 = compiler.context.add_symbol("x".to_string());
        let index2 = compiler.context.add_symbol("x".to_string());

        assert_eq!(index1, index2);
        assert_eq!(compiler.context.symbols.len(), 1);
    }

    #[test]
    fn test_eval_simple_arithmetic() {
        // Test 2 + 3
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(5));
    }

    #[test]
    fn test_eval_nested_arithmetic() {
        // Test (2 + 3) * 4 = 20
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol {
                        name: "Plus".to_string(),
                    })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(20));
    }

    #[test]
    fn test_eval_division() {
        // Test 8 / 2 = 4.0
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Divide".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(8)),
                Expr::Number(Number::Integer(2)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Real(4.0));
    }

    #[test]
    fn test_eval_power() {
        // Test 2^3 = 8
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Power".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(8));
    }

    #[test]
    fn test_compile_program() {
        let mut compiler = Compiler::new();
        let expressions = vec![
            Expr::Number(Number::Integer(42)),
            Expr::Function {
                head: Box::new(Expr::Symbol(Symbol {
                    name: "Plus".to_string(),
                })),
                args: vec![
                    Expr::Number(Number::Integer(1)),
                    Expr::Number(Number::Integer(2)),
                ],
            },
        ];

        compiler.compile_program(&expressions).unwrap();

        // Should generate: LDC 42, LDC 1, LDC 2, ADD (no halt)
        assert_eq!(compiler.context.code.len(), 4);
        assert_eq!(compiler.context.code[3].opcode, OpCode::ADD);
    }
}

use crate::{
    ast::{Expr, Number, Pattern},
    bytecode::{Instruction, OpCode},
    linker::{registry::create_global_registry, FunctionRegistry},
    stdlib::StandardLibrary,
    vm::{Value, VirtualMachine},
};
use std::collections::HashMap;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CompilerError {
    #[error("Unsupported expression: {0}")]
    UnsupportedExpression(String),
    #[error("Too many constants (max 16777215)")]
    TooManyConstants,
    #[error("Unknown function: {0}")]
    UnknownFunction(String),
    #[error("Invalid function arity: {function} expects {expected} args, got {actual}")]
    InvalidArity {
        function: String,
        expected: usize,
        actual: usize,
    },
    #[error("Unknown method: {type_name}.{method}")]
    UnknownMethod {
        type_name: String,
        method: String,
    },
    #[error("Invalid method arity: {method} expects {expected} args, got {actual}")]
    InvalidMethodArity {
        method: String,
        expected: usize,
        actual: usize,
    },
}

pub type CompilerResult<T> = std::result::Result<T, CompilerError>;

/// Compilation context for tracking constants and symbols
#[derive(Debug)]
pub struct CompilerContext {
    /// Constant pool - values indexed by position
    pub constants: Vec<Value>,
    /// Symbol table - maps symbol names to indices
    pub symbols: HashMap<String, usize>,
    /// Generated bytecode instructions
    pub code: Vec<Instruction>,
}

impl CompilerContext {
    pub fn new() -> Self {
        CompilerContext {
            constants: Vec::new(),
            symbols: HashMap::new(),
            code: Vec::new(),
        }
    }

    /// Add a constant to the pool, returns its index
    pub fn add_constant(&mut self, value: Value) -> CompilerResult<usize> {
        // Check for duplicates to avoid bloat
        for (i, existing) in self.constants.iter().enumerate() {
            if existing == &value {
                return Ok(i);
            }
        }

        if self.constants.len() >= 0xFFFFFF {
            return Err(CompilerError::TooManyConstants);
        }

        self.constants.push(value);
        Ok(self.constants.len() - 1)
    }

    /// Add a symbol to the table, returns its index
    pub fn add_symbol(&mut self, name: String) -> usize {
        if let Some(&index) = self.symbols.get(&name) {
            return index;
        }
        let index = self.symbols.len();
        self.symbols.insert(name, index);
        index
    }

    /// Emit an instruction
    pub fn emit(&mut self, opcode: OpCode, operand: u32) -> CompilerResult<()> {
        let instruction = Instruction::new(opcode, operand)
            .map_err(|_| CompilerError::UnsupportedExpression("Invalid instruction".to_string()))?;
        self.code.push(instruction);
        Ok(())
    }

    /// Get the current code position (for jumps)
    pub fn current_position(&self) -> usize {
        self.code.len()
    }
}

impl Default for CompilerContext {
    fn default() -> Self {
        Self::new()
    }
}

/// The main compiler
#[derive(Debug)]
pub struct Compiler {
    pub context: CompilerContext,
    pub stdlib: StandardLibrary,
    pub registry: FunctionRegistry,
}

impl Compiler {
    /// Create a new compiler
    pub fn new() -> Self {
        let mut registry = create_global_registry().expect("Failed to create function registry");
        
        // Initialize stdlib attributes for Phase 5A
        registry.register_stdlib_attributes();
        
        Compiler {
            context: CompilerContext::new(),
            stdlib: StandardLibrary::new(),
            registry,
        }
    }

    /// Compile an expression to bytecode
    pub fn compile_expr(&mut self, expr: &Expr) -> CompilerResult<()> {
        match expr {
            Expr::Number(Number::Integer(n)) => {
                // All integers now use constant pool with LDC
                let const_index = self.context.add_constant(Value::Integer(*n))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Number(Number::Real(f)) => {
                let const_index = self.context.add_constant(Value::Real(*f))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::String(s) => {
                let const_index = self.context.add_constant(Value::String(s.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Symbol(sym) => {
                // Symbols now loaded via constant pool with LDC
                let const_index = self.context.add_constant(Value::Symbol(sym.name.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::List(elements) => {
                // Compile each element and create a list
                let mut list_values = Vec::new();
                for element in elements {
                    // For now, we'll evaluate each element and add to list
                    // This is a simplified approach - a full implementation would
                    // handle this more efficiently at runtime
                    match element {
                        Expr::Number(Number::Integer(n)) => {
                            list_values.push(Value::Integer(*n));
                        }
                        Expr::Number(Number::Real(f)) => {
                            list_values.push(Value::Real(*f));
                        }
                        Expr::String(s) => {
                            list_values.push(Value::String(s.clone()));
                        }
                        Expr::Symbol(sym) => {
                            list_values.push(Value::Symbol(sym.name.clone()));
                        }
                        _ => {
                            // For complex expressions, we'd need to compile them and evaluate at runtime
                            // For now, just put the list in the constant pool
                            return Err(CompilerError::UnsupportedExpression(format!(
                                "Complex list element: {:?}",
                                element
                            )));
                        }
                    }
                }

                // Add the list to the constant pool
                let const_index = self.context.add_constant(Value::List(list_values))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Function { head, args } => {
                // Use attribute-aware compilation (Phase 5A.5.1a)
                self.compile_function_with_attributes(head, args)?;
            }
            Expr::Pattern(pattern) => {
                // Store pattern in constant pool as a Pattern value
                let const_index = self.context.add_constant(Value::Pattern(pattern.clone()))?;
                self.context.emit(OpCode::LDC, const_index as u32)?;
            }
            Expr::Replace { expr, rules, repeated } => {
                // Compile replace expressions (/.  and //.)
                self.compile_replace_expression(expr, rules, *repeated)?;
            }
            Expr::Rule { lhs, rhs, delayed } => {
                // Compile rule expressions (-> and :>)
                self.compile_rule_expression(lhs, rhs, *delayed)?;
            }
            Expr::DotCall { object, method, args } => {
                self.compile_method_call(object, method, args)?;
            }
            _ => {
                return Err(CompilerError::UnsupportedExpression(format!("{:?}", expr)));
            }
        }
        Ok(())
    }

    /// Compile a function call
    fn compile_function_call(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Check if this is a built-in arithmetic function that maps to a bytecode instruction
        if let Expr::Symbol(sym) = head {
            match sym.name.as_str() {
                "Plus" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Plus".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    // Compile arguments in order (left operand first)
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::ADD, 0)?;
                    return Ok(());
                }
                "Times" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Times".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::MUL, 0)?;
                    return Ok(());
                }
                "Divide" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Divide".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::DIV, 0)?;
                    return Ok(());
                }
                "Power" => {
                    if args.len() != 2 {
                        return Err(CompilerError::InvalidArity {
                            function: "Power".to_string(),
                            expected: 2,
                            actual: args.len(),
                        });
                    }
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.context.emit(OpCode::POW, 0)?;
                    return Ok(());
                }
                "Minus" => {
                    // Handle unary minus: Minus[x] -> 0 - x
                    if args.len() == 1 {
                        let zero_index = self.context.add_constant(Value::Integer(0))?;
                        self.context.emit(OpCode::LDC, zero_index as u32)?;
                        self.compile_expr(&args[0])?;
                        self.context.emit(OpCode::SUB, 0)?;
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Minus".to_string(),
                            expected: 1,
                            actual: args.len(),
                        });
                    }
                }
                _ => {
                    // Check if this is a stdlib function - use CALL_STATIC for 1000x+ speedup!
                    if let Some(stdlib_index) = self.registry.get_stdlib_index(&sym.name) {
                        // Compile arguments first
                        for arg in args {
                            self.compile_expr(arg)?;
                        }

                        // Emit CALL_STATIC with stdlib function index (32-78)
                        self.context.emit(OpCode::CALL_STATIC, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
                        return Ok(());
                    }
                    
                    // Try compile-time static method resolution
                    if !args.is_empty() {
                        // Check if this method exists in any Foreign type
                        let mut method_found = false;
                        let mut expected_arity = None;
                        
                        // Check all known Foreign types for this method
                        for type_name in self.registry.get_type_names() {
                            if self.registry.has_method(&type_name, &sym.name) {
                                method_found = true;
                                // Get arity from function signature (lookup requires mutable self)
                                // For now, we'll use hardcoded common method arities
                                expected_arity = Some(match sym.name.as_str() {
                                    "Length" | "Type" | "ToList" | "IsEmpty" | "Shape" | "Columns" | "Rows" => 0,
                                    "Get" | "Append" => 1, 
                                    "Set" | "Slice" => 2,
                                    _ => args.len(), // Allow any arity for unknown methods
                                });
                                break;
                            }
                        }
                        
                        if method_found {
                            // Validate arity at compile time
                            if let Some(expected) = expected_arity {
                                if args.len() != expected {
                                    return Err(CompilerError::InvalidMethodArity {
                                        method: sym.name.clone(),
                                        expected,
                                        actual: args.len(),
                                    });
                                }
                            }
                            
                            // Compile all arguments (first arg is the object)
                            for arg in args {
                                self.compile_expr(arg)?;
                            }
                            
                            // Map method name to function index (simplified mapping)
                            let function_index = match sym.name.as_str() {
                                "Length" => 0,
                                "Type" => 1, 
                                "ToList" => 2,
                                "IsEmpty" => 3,
                                "Get" => 4,
                                "Append" => 5,
                                "Set" => 6,
                                "Slice" => 7,
                                "Shape" => 8,
                                "Columns" => 9,
                                "Rows" => 10,
                                _ => 0, // Default fallback
                            };
                            let argc = args.len() as u8;
                            
                            // Generate CALL_STATIC instruction for static dispatch
                            let instruction = Instruction::new_call_static(function_index, argc)
                                .map_err(|_| CompilerError::TooManyConstants)?;
                            self.context.code.push(instruction);
                            return Ok(());
                        }
                    }
                    // For unknown functions with no args, fall through to error
                }
            }
        }

        // Handle unknown functions as symbolic expressions (for symbolic computation)
        // Create a symbolic function representation
        if let Expr::Symbol(sym) = head {
            // Compile arguments first
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            // Create a Function value representing the symbolic function call
            let function_repr = if args.is_empty() {
                sym.name.clone() // f becomes "f"
            } else {
                format!("{}[{}]", sym.name, "...".repeat(args.len())) // f[x,y] becomes "f[..,..]"
            };
            
            // Store the symbolic function as a Function value
            let const_index = self.context.add_constant(Value::Function(function_repr))?;
            self.context.emit(OpCode::LDC, const_index as u32)?;
            
            Ok(())
        } else {
            Err(CompilerError::UnknownFunction(format!("{:?}", head)))
        }
    }

    /// Compile a method call (obj.Method[args] syntax) using unified registry
    fn compile_method_call(&mut self, object: &Expr, method: &str, args: &[Expr]) -> CompilerResult<()> {
        // Search all known Foreign types for this method
        let mut method_found = false;
        let mut method_index = None;
        
        for type_name in self.registry.get_type_names() {
            if self.registry.has_method(&type_name, method) {
                method_found = true;
                method_index = self.registry.get_method_index(&type_name, method);
                break;
            }
        }
        
        if method_found && method_index.is_some() {
            // Compile object expression first
            self.compile_expr(object)?;
            
            // Compile arguments
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            let index = method_index.unwrap();
            // Emit CALL_STATIC with Foreign method index (0-31)
            self.context.emit(OpCode::CALL_STATIC, ((index as u32) << 8) | (args.len() as u32))?;
            return Ok(());
        }
        
        // Method not found in registry
        Err(CompilerError::UnknownMethod {
            type_name: "Unknown".to_string(),  // We don't know the type at compile time
            method: method.to_string(),
        })
    }

    /// Compile a complete program (list of expressions)
    pub fn compile_program(&mut self, expressions: &[Expr]) -> CompilerResult<()> {
        for expr in expressions {
            self.compile_expr(expr)?;
            // For statements, we might want to pop the result if it's not the last one
            // For now, keep all results on the stack
        }
        // No halt instruction needed - execution ends naturally
        Ok(())
    }

    /// Create a VM loaded with the compiled bytecode
    pub fn into_vm(self) -> VirtualMachine {
        let mut vm = VirtualMachine::new();
        vm.load(self.context.code, self.context.constants);

        // Copy symbol table to VM
        for (name, index) in self.context.symbols {
            vm.symbols.insert(name, index);
        }

        vm
    }

    /// Convenience method to compile and evaluate an expression
    pub fn eval(expr: &Expr) -> CompilerResult<Value> {
        let mut compiler = Compiler::new();
        compiler.compile_expr(expr)?;
        // No halt instruction needed

        let mut vm = compiler.into_vm();
        vm.run()
            .map_err(|e| CompilerError::UnsupportedExpression(format!("Runtime error: {:?}", e)))
    }
    
    // ================================
    // ATTRIBUTE PROCESSING INFRASTRUCTURE (Phase 5A.5.1a)
    // ================================
    
    /// Extract function name from the head expression of a function call
    /// 
    /// This handles simple cases like Symbol("Sin") and prepares for more complex cases
    pub fn extract_function_name(&self, head: &Expr) -> CompilerResult<String> {
        match head {
            Expr::Symbol(sym) => Ok(sym.name.clone()),
            _ => Err(CompilerError::UnsupportedExpression(format!(
                "Complex function head not yet supported: {:?}",
                head
            ))),
        }
    }
    
    /// Query function attributes from the registry
    /// 
    /// Returns the list of attributes for the given function, or empty list if none
    pub fn get_function_attributes(&self, function_name: &str) -> Vec<crate::linker::FunctionAttribute> {
        self.registry.get_function_attributes(function_name)
    }
    
    /// Check if a function has a specific attribute
    pub fn function_has_attribute(&self, function_name: &str, attribute: &crate::linker::FunctionAttribute) -> bool {
        self.registry.function_has_attribute(function_name, attribute)
    }
    
    /// Enhanced function call compilation with attribute processing
    /// 
    /// This is the new entry point that will replace direct compile_function_call usage
    /// for attribute-aware compilation
    fn compile_function_with_attributes(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Step 1: Extract function name
        let function_name = self.extract_function_name(head)?;
        
        // Step 2: Query attributes
        let attributes = self.get_function_attributes(&function_name);
        
        // Step 3: Apply attribute-specific processing (Phase 5A.5.1b-d)
        if !attributes.is_empty() {
            println!("🔍 Found attributes for {}: {:?}", function_name, attributes);
            
            // Phase 5A.5.1b: Process Hold attributes (highest priority)
            for attribute in &attributes {
                if let crate::linker::FunctionAttribute::Hold(positions) = attribute {
                    return self.compile_function_with_hold(head, args, positions);
                }
            }
            
            // Check if there are list arguments for Listable priority decision
            let has_list_args = args.iter().any(|arg| matches!(arg, Expr::List(_)));
            
            // Priority: If there are list arguments, Listable takes precedence over Orderless
            if has_list_args {
                // Phase 5A.5.1c: Process Listable attributes FIRST when lists are present
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Listable = attribute {
                        return self.compile_function_with_listable(head, args);
                    }
                }
                
                // Phase 5A.5.1d: Process Orderless attributes as fallback
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Orderless = attribute {
                        return self.compile_function_with_orderless(head, args);
                    }
                }
            } else {
                // Phase 5A.5.1d: Process Orderless attributes FIRST when no lists present
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Orderless = attribute {
                        return self.compile_function_with_orderless(head, args);
                    }
                }
                
                // Phase 5A.5.1c: Process Listable attributes as fallback
                for attribute in &attributes {
                    if let crate::linker::FunctionAttribute::Listable = attribute {
                        return self.compile_function_with_listable(head, args);
                    }
                }
            }
        }
        
        // Step 4: Fallback to existing compilation logic for now
        self.compile_function_call(head, args)
    }
    
    /// Compile function call with Hold attribute processing
    /// 
    /// Hold positions are 1-indexed (Hold[1] means hold the first argument)
    fn compile_function_with_hold(&mut self, head: &Expr, args: &[Expr], hold_positions: &[usize]) -> CompilerResult<()> {
        // Compile arguments, using LOAD_QUOTE for held positions
        for (i, arg) in args.iter().enumerate() {
            let position = i + 1; // Convert to 1-indexed
            
            if hold_positions.contains(&position) {
                // This argument should be held (not evaluated)
                // Store the AST expression as a Quote value in the constant pool
                let quote_value = crate::vm::Value::Quote(Box::new(arg.clone()));
                let const_index = self.context.add_constant(quote_value)?;
                self.context.emit(OpCode::LOAD_QUOTE, const_index as u32)?;
            } else {
                // Normal argument - compile and evaluate as usual
                self.compile_expr(arg)?;
            }
        }
        
        // Now emit the actual function call after processing Hold arguments
        // Use the normal function compilation path since arguments are already on stack
        if let Expr::Symbol(symbol) = head {
            // Look up the function in the registry
            if let Some(function_index) = self.registry.get_stdlib_index(&symbol.name) {
                // Emit CALL_STATIC with proper argument count
                let argc = args.len();
                let operand = ((function_index as u32) << 8) | (argc as u32);
                self.context.emit(OpCode::CALL_STATIC, operand)?;
                Ok(())
            } else {
                Err(CompilerError::UnknownFunction(symbol.name.clone()))
            }
        } else {
            Err(CompilerError::UnsupportedExpression("Expected symbol for function head".to_string()))
        }
    }
    
    /// Compile function call with Listable attribute processing
    /// 
    /// Listable functions automatically thread over lists:
    /// - Sin[{1,2,3}] → {Sin[1], Sin[2], Sin[3]}
    /// - Plus[{1,2}, {3,4}] → {Plus[1,3], Plus[2,4]}
    /// - Plus[{1,2}, 10] → {Plus[1,10], Plus[2,10]}
    fn compile_function_with_listable(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Step 1: Check if any arguments are lists
        let mut has_list_args = false;
        for arg in args {
            if matches!(arg, Expr::List(_)) {
                has_list_args = true;
                break;
            }
        }
        
        // Step 2: If no list arguments, use normal CALL_STATIC compilation
        if !has_list_args {
            return self.compile_function_call(head, args);
        }
        
        // Step 3: List arguments found - use MAP_CALL_STATIC for list threading
        // First, extract function name and determine if it's stdlib or Foreign method
        let function_name = self.extract_function_name(head)?;
        
        // Step 3a: Handle special arithmetic functions (Plus, Times, etc.)
        // These are compiled to opcodes normally, but for Listable with lists we need special handling
        match function_name.as_str() {
            "Plus" | "Times" | "Divide" | "Power" | "Minus" => {
                // For arithmetic functions with lists, we need to find the equivalent stdlib function
                // or handle them specially. For now, let's try to find them in stdlib.
                
                // Check if this arithmetic function is registered in stdlib
                if let Some(stdlib_index) = self.registry.get_stdlib_index(&function_name) {
                    // Compile arguments normally (lists will be evaluated as list values)
                    for arg in args {
                        self.compile_expr(arg)?;
                    }
                    
                    // Emit MAP_CALL_STATIC with stdlib function index
                    self.context.emit(OpCode::MAP_CALL_STATIC, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
                    return Ok(());
                } else {
                    // Arithmetic function not found in stdlib registry
                    // This means we need to fall back to existing arithmetic compilation
                    // but that won't work with lists. For now, return an error.
                    return Err(CompilerError::UnknownFunction(format!(
                        "Arithmetic function {} with Listable attribute and list arguments needs stdlib registration", 
                        function_name
                    )));
                }
            }
            _ => {
                // Not a special arithmetic function, proceed with normal processing
            }
        }
        
        // Check if this is a stdlib function
        if let Some(stdlib_index) = self.registry.get_stdlib_index(&function_name) {
            // Compile arguments normally (lists will be evaluated as list values)
            for arg in args {
                self.compile_expr(arg)?;
            }
            
            // Emit MAP_CALL_STATIC with stdlib function index (32+)
            self.context.emit(OpCode::MAP_CALL_STATIC, ((stdlib_index as u32) << 8) | (args.len() as u32))?;
            return Ok(());
        }
        
        // Check if this is a method call that should be compiled as static method call
        if !args.is_empty() {
            // Check if this method exists in any Foreign type 
            for type_name in self.registry.get_type_names() {
                if self.registry.has_method(&type_name, &function_name) {
                    // Compile all arguments (first arg is the object)
                    for arg in args {
                        self.compile_expr(arg)?;
                    }
                    
                    // Map method name to function index (same mapping as in existing code)
                    let function_index = match function_name.as_str() {
                        "Length" => 0, "Type" => 1, "ToList" => 2, "IsEmpty" => 3,
                        "Get" => 4, "Append" => 5, "Set" => 6, "Slice" => 7,
                        "Shape" => 8, "Columns" => 9, "Rows" => 10,
                        _ => 0, // Default fallback
                    };
                    
                    // Generate MAP_CALL_STATIC instruction for static dispatch with list threading
                    self.context.emit(OpCode::MAP_CALL_STATIC, ((function_index as u32) << 8) | (args.len() as u32))?;
                    return Ok(());
                }
            }
        }
        
        // Function not found in registry - this should not happen for registered Listable functions
        Err(CompilerError::UnknownFunction(format!("Listable function {} not found in registry", function_name)))
    }
    
    /// Compile function call with Orderless attribute processing
    /// 
    /// Orderless functions have their arguments sorted in canonical order:
    /// - Numbers: sorted numerically (1, 2, 3)
    /// - Symbols: sorted alphabetically (a, b, c)
    /// - Complex expressions: sorted by a canonical ordering system
    fn compile_function_with_orderless(&mut self, head: &Expr, args: &[Expr]) -> CompilerResult<()> {
        // Step 1: Sort arguments according to canonical order
        let mut sorted_args = args.to_vec();
        sorted_args.sort_by(|a, b| self.canonical_order(a, b));
        
        // Step 2: Handle special cases for arithmetic functions with Orderless
        if let Expr::Symbol(sym) = head {
            match sym.name.as_str() {
                "Plus" => {
                    // For Orderless Plus with multiple arguments, we need to compile them 
                    // as a sequence of binary additions: Plus[a, b, c] -> Plus[Plus[a, b], c]
                    if sorted_args.len() >= 2 {
                        // Compile first argument
                        self.compile_expr(&sorted_args[0])?;
                        
                        // Add each subsequent argument with binary Plus
                        for arg in &sorted_args[1..] {
                            self.compile_expr(arg)?;
                            self.context.emit(OpCode::ADD, 0)?;
                        }
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Plus".to_string(),
                            expected: 2,
                            actual: sorted_args.len(),
                        });
                    }
                }
                "Times" => {
                    // Similar handling for Times
                    if sorted_args.len() >= 2 {
                        self.compile_expr(&sorted_args[0])?;
                        for arg in &sorted_args[1..] {
                            self.compile_expr(arg)?;
                            self.context.emit(OpCode::MUL, 0)?;
                        }
                        return Ok(());
                    } else {
                        return Err(CompilerError::InvalidArity {
                            function: "Times".to_string(),
                            expected: 2,
                            actual: sorted_args.len(),
                        });
                    }
                }
                _ => {
                    // For other functions, check if it's a stdlib function and handle accordingly
                    if let Some(stdlib_index) = self.registry.get_stdlib_index(&sym.name) {
                        // Compile sorted arguments normally
                        for arg in &sorted_args {
                            self.compile_expr(arg)?;
                        }
                        
                        // Emit CALL_STATIC with stdlib function index
                        self.context.emit(OpCode::CALL_STATIC, ((stdlib_index as u32) << 8) | (sorted_args.len() as u32))?;
                        return Ok(());
                    }
                }
            }
        }
        
        // Step 3: Fallback to normal function compilation for non-arithmetic functions
        self.compile_function_call(head, &sorted_args)
    }
    
    /// Canonical ordering for expressions (implements Mathematica-like ordering)
    /// 
    /// Ordering rules:
    /// 1. Numbers come before symbols
    /// 2. Symbols come before function calls
    /// 3. Numbers are sorted numerically
    /// 4. Symbols are sorted alphabetically
    /// 5. Function calls are sorted by head name, then by arguments
    fn canonical_order(&self, a: &Expr, b: &Expr) -> std::cmp::Ordering {
        use std::cmp::Ordering;
        use crate::ast::{Expr, Number};
        
        match (a, b) {
            // Numbers vs Numbers: sort numerically
            (Expr::Number(Number::Integer(x)), Expr::Number(Number::Integer(y))) => x.cmp(y),
            (Expr::Number(Number::Real(x)), Expr::Number(Number::Real(y))) => {
                x.partial_cmp(y).unwrap_or(Ordering::Equal)
            }
            (Expr::Number(Number::Integer(x)), Expr::Number(Number::Real(y))) => {
                (*x as f64).partial_cmp(y).unwrap_or(Ordering::Equal)
            }
            (Expr::Number(Number::Real(x)), Expr::Number(Number::Integer(y))) => {
                x.partial_cmp(&(*y as f64)).unwrap_or(Ordering::Equal)
            }
            
            // Numbers vs anything else: numbers come first
            (Expr::Number(_), _) => Ordering::Less,
            (_, Expr::Number(_)) => Ordering::Greater,
            
            // Symbols vs Symbols: sort alphabetically
            (Expr::Symbol(sym_a), Expr::Symbol(sym_b)) => sym_a.name.cmp(&sym_b.name),
            
            // Symbols vs anything else (except numbers): symbols come first
            (Expr::Symbol(_), _) => Ordering::Less,
            (_, Expr::Symbol(_)) => Ordering::Greater,
            
            // Functions vs Functions: sort by head name, then by arguments
            (Expr::Function { head: head_a, args: args_a }, Expr::Function { head: head_b, args: args_b }) => {
                // First compare the function heads
                let head_cmp = self.canonical_order(head_a, head_b);
                if head_cmp != Ordering::Equal {
                    return head_cmp;
                }
                
                // Then compare argument count
                let arity_cmp = args_a.len().cmp(&args_b.len());
                if arity_cmp != Ordering::Equal {
                    return arity_cmp;
                }
                
                // Finally compare arguments pairwise
                for (arg_a, arg_b) in args_a.iter().zip(args_b.iter()) {
                    let arg_cmp = self.canonical_order(arg_a, arg_b);
                    if arg_cmp != Ordering::Equal {
                        return arg_cmp;
                    }
                }
                
                Ordering::Equal
            }
            
            // Strings vs Strings: sort alphabetically
            (Expr::String(s_a), Expr::String(s_b)) => s_a.cmp(s_b),
            
            // Default cases - maintain some consistent ordering for other expression types
            // Lists come after symbols but before functions
            (Expr::List(_), Expr::Function { .. }) => Ordering::Less,
            (Expr::Function { .. }, Expr::List(_)) => Ordering::Greater,
            (Expr::List(_), _) => Ordering::Greater,
            (_, Expr::List(_)) => Ordering::Less,
            
            // Strings come after symbols but before functions
            (Expr::String(_), Expr::Function { .. }) => Ordering::Less,
            (Expr::Function { .. }, Expr::String(_)) => Ordering::Greater,
            
            // For any other cases, use a consistent default
            _ => Ordering::Equal,
        }
    }

    /// Compile replace expressions (expr /. rules and expr //. rules)
    fn compile_replace_expression(&mut self, expr: &Expr, rules: &Expr, repeated: bool) -> CompilerResult<()> {
        // Compile the expression to be transformed
        self.compile_expr(expr)?;
        
        // Compile the rules
        self.compile_expr(rules)?;
        
        // For now, call the ReplaceAll stdlib function
        // Later we might want ReplaceRepeated for the //. case
        let function_name = if repeated { "ReplaceRepeated" } else { "ReplaceAll" };
        
        if let Some(stdlib_index) = self.registry.get_stdlib_index(function_name) {
            // Emit CALL_STATIC with stdlib function index
            self.context.emit(OpCode::CALL_STATIC, ((stdlib_index as u32) << 8) | 2)?;
            Ok(())
        } else {
            Err(CompilerError::UnknownFunction(format!(
                "Replace function {} not found in stdlib", function_name
            )))
        }
    }

    /// Compile rule expressions (lhs -> rhs and lhs :> rhs)
    fn compile_rule_expression(&mut self, lhs: &Expr, rhs: &Expr, delayed: bool) -> CompilerResult<()> {
        // For now, create a function representation of the rule
        // This is similar to how the stdlib Rule function works
        let rule_type = if delayed { "RuleDelayed" } else { "Rule" };
        let rule_repr = format!("{}[{:?}, {:?}]", rule_type, lhs, rhs);
        
        // Store the rule as a Function value in constants
        let const_index = self.context.add_constant(Value::Function(rule_repr))?;
        self.context.emit(OpCode::LDC, const_index as u32)?;
        
        Ok(())
    }
}

impl Default for Compiler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::{Expr, Number, Symbol};

    #[test]
    fn test_compile_integer_small() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(42));

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 42);
    }

    #[test]
    fn test_compile_integer_large() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Integer(0x1000000)); // Larger than 24-bit

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Integer(0x1000000));
    }

    #[test]
    fn test_compile_real() {
        let mut compiler = Compiler::new();
        let expr = Expr::Number(Number::Real(3.14));

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(compiler.context.constants[0], Value::Real(3.14));
    }

    #[test]
    fn test_compile_string() {
        let mut compiler = Compiler::new();
        let expr = Expr::String("hello".to_string());

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.constants.len(), 1);
        assert_eq!(
            compiler.context.constants[0],
            Value::String("hello".to_string())
        );
    }

    #[test]
    fn test_compile_symbol() {
        let mut compiler = Compiler::new();
        let expr = Expr::Symbol(Symbol {
            name: "x".to_string(),
        });

        compiler.compile_expr(&expr).unwrap();

        assert_eq!(compiler.context.code.len(), 1);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.symbols.len(), 1);
        assert_eq!(compiler.context.symbols["x"], 0);
    }

    #[test]
    fn test_compile_plus() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 2, Push 3, Add
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::ADD);
    }

    #[test]
    fn test_compile_times() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(4)),
                Expr::Number(Number::Integer(5)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 4, Push 5, Mul
        assert_eq!(compiler.context.code.len(), 3);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 4);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 5);
        assert_eq!(compiler.context.code[2].opcode, OpCode::MUL);
    }

    #[test]
    fn test_compile_nested_arithmetic() {
        let mut compiler = Compiler::new();
        // (2 + 3) * 4 -> Times[Plus[2, 3], 4]
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol {
                        name: "Plus".to_string(),
                    })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };

        compiler.compile_expr(&expr).unwrap();

        // Should generate: Push 2, Push 3, Add, Push 4, Mul
        assert_eq!(compiler.context.code.len(), 5);
        assert_eq!(compiler.context.code[0].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[0].operand, 2);
        assert_eq!(compiler.context.code[1].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[1].operand, 3);
        assert_eq!(compiler.context.code[2].opcode, OpCode::ADD);
        assert_eq!(compiler.context.code[3].opcode, OpCode::LDC);
        assert_eq!(compiler.context.code[3].operand, 4);
        assert_eq!(compiler.context.code[4].opcode, OpCode::MUL);
    }

    #[test]
    fn test_invalid_arity() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![Expr::Number(Number::Integer(1))], // Only one argument
        };

        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::InvalidArity {
                function,
                expected,
                actual,
            } => {
                assert_eq!(function, "Plus");
                assert_eq!(expected, 2);
                assert_eq!(actual, 1);
            }
            _ => panic!("Expected InvalidArity error"),
        }
    }

    #[test]
    fn test_unknown_function() {
        let mut compiler = Compiler::new();
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "UnknownFunc".to_string(),
            })),
            args: vec![],
        };

        let result = compiler.compile_expr(&expr);
        assert!(result.is_err());
        match result.unwrap_err() {
            CompilerError::UnknownFunction(_) => {}
            _ => panic!("Expected UnknownFunction error"),
        }
    }

    #[test]
    fn test_constant_deduplication() {
        let mut compiler = Compiler::new();

        // Add the same constant twice
        let index1 = compiler.context.add_constant(Value::Integer(42)).unwrap();
        let index2 = compiler.context.add_constant(Value::Integer(42)).unwrap();

        assert_eq!(index1, index2);
        assert_eq!(compiler.context.constants.len(), 1);
    }

    #[test]
    fn test_symbol_deduplication() {
        let mut compiler = Compiler::new();

        // Add the same symbol twice
        let index1 = compiler.context.add_symbol("x".to_string());
        let index2 = compiler.context.add_symbol("x".to_string());

        assert_eq!(index1, index2);
        assert_eq!(compiler.context.symbols.len(), 1);
    }

    #[test]
    fn test_eval_simple_arithmetic() {
        // Test 2 + 3
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Plus".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(5));
    }

    #[test]
    fn test_eval_nested_arithmetic() {
        // Test (2 + 3) * 4 = 20
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Times".to_string(),
            })),
            args: vec![
                Expr::Function {
                    head: Box::new(Expr::Symbol(Symbol {
                        name: "Plus".to_string(),
                    })),
                    args: vec![
                        Expr::Number(Number::Integer(2)),
                        Expr::Number(Number::Integer(3)),
                    ],
                },
                Expr::Number(Number::Integer(4)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(20));
    }

    #[test]
    fn test_eval_division() {
        // Test 8 / 2 = 4.0
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Divide".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(8)),
                Expr::Number(Number::Integer(2)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Real(4.0));
    }

    #[test]
    fn test_eval_power() {
        // Test 2^3 = 8
        let expr = Expr::Function {
            head: Box::new(Expr::Symbol(Symbol {
                name: "Power".to_string(),
            })),
            args: vec![
                Expr::Number(Number::Integer(2)),
                Expr::Number(Number::Integer(3)),
            ],
        };

        let result = Compiler::eval(&expr).unwrap();
        assert_eq!(result, Value::Integer(8));
    }

    #[test]
    fn test_compile_program() {
        let mut compiler = Compiler::new();
        let expressions = vec![
            Expr::Number(Number::Integer(42)),
            Expr::Function {
                head: Box::new(Expr::Symbol(Symbol {
                    name: "Plus".to_string(),
                })),
                args: vec![
                    Expr::Number(Number::Integer(1)),
                    Expr::Number(Number::Integer(2)),
                ],
            },
        ];

        compiler.compile_program(&expressions).unwrap();

        // Should generate: LDC 42, LDC 1, LDC 2, ADD (no halt)
        assert_eq!(compiler.context.code.len(), 4);
        assert_eq!(compiler.context.code[3].opcode, OpCode::ADD);
    }
}

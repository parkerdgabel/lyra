(* Lyra Core Grammar (EBNF) *)

program      := { statement } ;
statement    := expression | rule | comment ;

expression   := literal
              | symbol
              | list
              | association
              | call
              | pure_function
              | pattern
              | method_call
              | grouped
              ;

literal      := integer | real | string | boolean | Missing ;
integer      := ["+"|"-"] digit { digit } ;
real         := ["+"|"-"] digit { digit } "." { digit } [ ("e"|"E") ["+"|"-"] digit { digit } ]
              | ["+"|"-"] "." digit { digit } [ ("e"|"E") ["+"|"-"] digit { digit } ] ;
string       := '"' { character | escape } '"' ;
boolean      := "True" | "False" ;

symbol       := letter { letter | digit | '_' | '$' } ;

list         := '{' [ expression { ',' expression } ] '}' ;

pair         := (symbol | string) '->' expression ;
association  := '<|' [ pair { ',' pair } ] '|>' ;

call         := head '[' [ expression { ',' expression } ] ']' ;
head         := symbol ;

pure_function := expression '&' ;

pattern      := blank | named_blank | blank_seq | blank_null_seq ;
blank        := '_' [ head ] ;
named_blank  := symbol '_' [ head ] ;
blank_seq    := '__' [ head ] ;
blank_null_seq := '___' [ head ] ;

rule         := expression ('->' | ':>') expression ;

method_call  := expression '@' symbol [ '[' [ expression { ',' expression } ] ']' ] ;

grouped      := '(' expression ')' ;

comment      := '(*' { any_char } '*)' ;

letter       := 'A'..'Z' | 'a'..'z' | '$' ;
digit        := '0'..'9' ;
escape       := '\\' any_char ;
character    := any_char - '"' ;
any_char     := ? any unicode scalar value ? ;

(* This EBNF describes core constructs; the actual parser may accept additional
   operators and syntactic sugars consistent with the runtime. *)


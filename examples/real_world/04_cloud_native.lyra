(*
==============================================================================
CLOUD-NATIVE APPLICATION - MICROSERVICES & CONTAINER ORCHESTRATION
==============================================================================

A comprehensive cloud-native application demonstrating Lyra's cloud capabilities:
- Docker container management and multi-service architecture
- Kubernetes deployment and service orchestration  
- Cloud storage operations (S3, Azure Blob, GCS)
- Microservices communication patterns
- Service mesh and load balancing
- Configuration management and secrets
- Monitoring, logging, and observability
- Auto-scaling and fault tolerance

This example builds a distributed e-commerce platform with multiple services
running in containers, orchestrated by Kubernetes, with full observability.
==============================================================================
*)

(* =========================== CONFIGURATION =========================== *)

(* Cloud platform configuration *)
cloudConfig = {
    "provider" -> "aws", (* aws | azure | gcp *)
    "region" -> "us-west-2",
    "clusterName" -> "lyra-ecommerce",
    "namespace" -> "production",
    "environment" -> "prod"
};

(* Container registry configuration *)
registryConfig = {
    "registry" -> "your-account.dkr.ecr.us-west-2.amazonaws.com",
    "imageTags" -> {
        "api" -> "lyra-api:v1.2.3",
        "worker" -> "lyra-worker:v1.2.3",
        "frontend" -> "lyra-frontend:v1.2.3",
        "database" -> "postgres:13"
    }
};

(* Service configuration *)
serviceConfig = {
    "api" -> {
        "replicas" -> 3,
        "cpu" -> "500m",
        "memory" -> "512Mi",
        "port" -> 8080,
        "healthCheck" -> "/health"
    },
    "worker" -> {
        "replicas" -> 2,
        "cpu" -> "1000m",
        "memory" -> "1Gi",
        "queues" -> {"order-processing", "email-notifications", "inventory-sync"}
    },
    "database" -> {
        "replicas" -> 1,
        "cpu" -> "2000m",
        "memory" -> "4Gi",
        "storage" -> "100Gi",
        "storageClass" -> "gp2"
    },
    "redis" -> {
        "replicas" -> 1,
        "cpu" -> "250m",
        "memory" -> "256Mi",
        "storage" -> "10Gi"
    }
};

(* Monitoring and observability *)
observabilityConfig = {
    "metrics" -> {
        "prometheus" -> True,
        "grafana" -> True,
        "alertmanager" -> True
    },
    "logging" -> {
        "elasticsearch" -> True,
        "kibana" -> True,
        "fluentd" -> True
    },
    "tracing" -> {
        "jaeger" -> True,
        "zipkin" -> False
    }
};

(* =========================== CONTAINER MANAGEMENT =========================== *)

(* Container builder and management *)
ContainerManager[registry_String] := {
    (* Build Docker image *)
    "buildImage" -> Function[{serviceName, dockerfile, context},
        Module[{imageTag, buildResult},
            imageTag = registry <> "/" <> registryConfig["imageTags"][serviceName];
            
            Log["INFO", "Building container image: " <> imageTag];
            
            buildResult = ContainerRun[
                "docker", "build",
                "-t", imageTag,
                "-f", dockerfile,
                context
            ];
            
            If[buildResult["exitCode"] == 0,
                Log["INFO", "Image built successfully: " <> imageTag];
                imageTag
            ,
                ThrowError["Failed to build image: " <> buildResult["stderr"]]
            ]
        ]
    ],
    
    (* Push image to registry *)
    "pushImage" -> Function[imageTag,
        Module[{pushResult},
            Log["INFO", "Pushing image to registry: " <> imageTag];
            
            pushResult = ContainerRun["docker", "push", imageTag];
            
            If[pushResult["exitCode"] == 0,
                Log["INFO", "Image pushed successfully"];
                True
            ,
                ThrowError["Failed to push image: " <> pushResult["stderr"]]
            ]
        ]
    ],
    
    (* Build and push all services *)
    "buildAllServices" -> Function[{},
        Module[{results},
            results = {};
            
            (* API Service *)
            apiImage = this["buildImage"]["api", "docker/api/Dockerfile", "src/api/"];
            this["pushImage"][apiImage];
            AppendTo[results, "api" -> apiImage];
            
            (* Worker Service *)
            workerImage = this["buildImage"]["worker", "docker/worker/Dockerfile", "src/worker/"];
            this["pushImage"][workerImage];
            AppendTo[results, "worker" -> workerImage];
            
            (* Frontend Service *)
            frontendImage = this["buildImage"]["frontend", "docker/frontend/Dockerfile", "src/frontend/"];
            this["pushImage"][frontendImage];
            AppendTo[results, "frontend" -> frontendImage];
            
            Log["INFO", "All services built and pushed successfully"];
            results
        ]
    ],
    
    (* Run local development containers *)
    "runDevelopment" -> Function[{},
        Module[{composeFile},
            composeFile = "docker-compose.dev.yml";
            
            Log["INFO", "Starting development containers"];
            
            result = ContainerRun["docker-compose", "-f", composeFile, "up", "-d"];
            
            If[result["exitCode"] == 0,
                Log["INFO", "Development environment started"];
                True
            ,
                ThrowError["Failed to start development environment: " <> result["stderr"]]
            ]
        ]
    ]
};

(* =========================== KUBERNETES DEPLOYMENT =========================== *)

(* Kubernetes deployment manager *)
KubernetesManager[clusterConfig_Association] := {
    (* Deploy application to Kubernetes *)
    "deployApplication" -> Function[{},
        Module[{deploymentSpecs, services, configMaps, secrets},
            Log["INFO", "Deploying application to Kubernetes"];
            
            (* Create namespace *)
            this["createNamespace"][clusterConfig["namespace"]];
            
            (* Deploy configuration *)
            configMaps = this["deployConfigMaps"][];
            secrets = this["deploySecrets"][];
            
            (* Deploy services *)
            database = this["deployDatabase"][];
            redis = this["deployRedis"][];
            api = this["deployAPIService"][];
            worker = this["deployWorkerService"][];
            frontend = this["deployFrontendService"][];
            
            (* Deploy ingress *)
            ingress = this["deployIngress"][];
            
            (* Deploy monitoring *)
            monitoring = this["deployMonitoring"][];
            
            Log["INFO", "Application deployed successfully"];
            
            {
                "namespace" -> clusterConfig["namespace"],
                "services" -> {database, redis, api, worker, frontend},
                "ingress" -> ingress,
                "monitoring" -> monitoring
            }
        ]
    ],
    
    (* Create Kubernetes namespace *)
    "createNamespace" -> Function[namespace,
        Module[{namespaceSpec, result},
            namespaceSpec = {
                "apiVersion" -> "v1",
                "kind" -> "Namespace",
                "metadata" -> {
                    "name" -> namespace,
                    "labels" -> {
                        "app.kubernetes.io/name" -> "lyra-ecommerce",
                        "app.kubernetes.io/environment" -> clusterConfig["environment"]
                    }
                }
            };
            
            result = KubernetesService["apply", JSONStringify[namespaceSpec]];
            
            If[result["success"],
                Log["INFO", "Namespace created: " <> namespace];
                True
            ,
                Log["WARN", "Namespace may already exist: " <> namespace];
                True
            ]
        ]
    ],
    
    (* Deploy database with persistent storage *)
    "deployDatabase" -> Function[{},
        Module[{pvc, deployment, service},
            Log["INFO", "Deploying PostgreSQL database"];
            
            (* Persistent Volume Claim *)
            pvc = {
                "apiVersion" -> "v1",
                "kind" -> "PersistentVolumeClaim",
                "metadata" -> {
                    "name" -> "postgres-pvc",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "accessModes" -> {"ReadWriteOnce"},
                    "storageClassName" -> serviceConfig["database"]["storageClass"],
                    "resources" -> {
                        "requests" -> {
                            "storage" -> serviceConfig["database"]["storage"]
                        }
                    }
                }
            };
            
            (* Database Deployment *)
            deployment = {
                "apiVersion" -> "apps/v1",
                "kind" -> "Deployment",
                "metadata" -> {
                    "name" -> "postgres",
                    "namespace" -> clusterConfig["namespace"],
                    "labels" -> {"app" -> "postgres"}
                },
                "spec" -> {
                    "replicas" -> serviceConfig["database"]["replicas"],
                    "selector" -> {"matchLabels" -> {"app" -> "postgres"}},
                    "template" -> {
                        "metadata" -> {"labels" -> {"app" -> "postgres"}},
                        "spec" -> {
                            "containers" -> {{
                                "name" -> "postgres",
                                "image" -> registryConfig["imageTags"]["database"],
                                "ports" -> {{"containerPort" -> 5432}},
                                "env" -> {
                                    {"name" -> "POSTGRES_DB", "value" -> "ecommerce"},
                                    {"name" -> "POSTGRES_USER", "value" -> "lyra"},
                                    {"name" -> "POSTGRES_PASSWORD", "valueFrom" -> {
                                        "secretKeyRef" -> {"name" -> "db-secret", "key" -> "password"}
                                    }}
                                },
                                "resources" -> {
                                    "requests" -> {
                                        "cpu" -> serviceConfig["database"]["cpu"],
                                        "memory" -> serviceConfig["database"]["memory"]
                                    },
                                    "limits" -> {
                                        "cpu" -> serviceConfig["database"]["cpu"],
                                        "memory" -> serviceConfig["database"]["memory"]
                                    }
                                },
                                "volumeMounts" -> {{
                                    "name" -> "postgres-storage",
                                    "mountPath" -> "/var/lib/postgresql/data"
                                }}
                            }},
                            "volumes" -> {{
                                "name" -> "postgres-storage",
                                "persistentVolumeClaim" -> {"claimName" -> "postgres-pvc"}
                            }}
                        }
                    }
                }
            };
            
            (* Database Service *)
            service = {
                "apiVersion" -> "v1",
                "kind" -> "Service",
                "metadata" -> {
                    "name" -> "postgres-service",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "selector" -> {"app" -> "postgres"},
                    "ports" -> {{"port" -> 5432, "targetPort" -> 5432}},
                    "type" -> "ClusterIP"
                }
            };
            
            (* Apply all resources *)
            KubernetesService["apply", JSONStringify[pvc]];
            KubernetesService["apply", JSONStringify[deployment]];
            KubernetesService["apply", JSONStringify[service]];
            
            Log["INFO", "PostgreSQL database deployed"];
            {"pvc" -> pvc, "deployment" -> deployment, "service" -> service}
        ]
    ],
    
    (* Deploy API service with auto-scaling *)
    "deployAPIService" -> Function[{},
        Module[{deployment, service, hpa, podDisruptionBudget},
            Log["INFO", "Deploying API service"];
            
            (* API Deployment *)
            deployment = {
                "apiVersion" -> "apps/v1",
                "kind" -> "Deployment",
                "metadata" -> {
                    "name" -> "api",
                    "namespace" -> clusterConfig["namespace"],
                    "labels" -> {"app" -> "api"}
                },
                "spec" -> {
                    "replicas" -> serviceConfig["api"]["replicas"],
                    "selector" -> {"matchLabels" -> {"app" -> "api"}},
                    "template" -> {
                        "metadata" -> {
                            "labels" -> {"app" -> "api"},
                            "annotations" -> {
                                "prometheus.io/scrape" -> "true",
                                "prometheus.io/port" -> "8080",
                                "prometheus.io/path" -> "/metrics"
                            }
                        },
                        "spec" -> {
                            "containers" -> {{
                                "name" -> "api",
                                "image" -> registryConfig["registry"] <> "/" <> registryConfig["imageTags"]["api"],
                                "ports" -> {
                                    {"containerPort" -> serviceConfig["api"]["port"], "name" -> "http"},
                                    {"containerPort" -> 9090, "name" -> "metrics"}
                                },
                                "env" -> {
                                    {"name" -> "DATABASE_URL", "valueFrom" -> {
                                        "secretKeyRef" -> {"name" -> "db-secret", "key" -> "url"}
                                    }},
                                    {"name" -> "REDIS_URL", "value" -> "redis://redis-service:6379"},
                                    {"name" -> "ENVIRONMENT", "value" -> clusterConfig["environment"]}
                                },
                                "resources" -> {
                                    "requests" -> {
                                        "cpu" -> serviceConfig["api"]["cpu"],
                                        "memory" -> serviceConfig["api"]["memory"]
                                    },
                                    "limits" -> {
                                        "cpu" -> "1000m",
                                        "memory" -> "1Gi"
                                    }
                                },
                                "livenessProbe" -> {
                                    "httpGet" -> {
                                        "path" -> serviceConfig["api"]["healthCheck"],
                                        "port" -> "http"
                                    },
                                    "initialDelaySeconds" -> 30,
                                    "periodSeconds" -> 10
                                },
                                "readinessProbe" -> {
                                    "httpGet" -> {
                                        "path" -> serviceConfig["api"]["healthCheck"],
                                        "port" -> "http"
                                    },
                                    "initialDelaySeconds" -> 5,
                                    "periodSeconds" -> 5
                                }
                            }},
                            "imagePullSecrets" -> {{"name" -> "registry-secret"}}
                        }
                    }
                }
            };
            
            (* API Service *)
            service = {
                "apiVersion" -> "v1",
                "kind" -> "Service",
                "metadata" -> {
                    "name" -> "api-service",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "selector" -> {"app" -> "api"},
                    "ports" -> {
                        {"port" -> 80, "targetPort" -> "http", "name" -> "http"},
                        {"port" -> 9090, "targetPort" -> "metrics", "name" -> "metrics"}
                    },
                    "type" -> "ClusterIP"
                }
            };
            
            (* Horizontal Pod Autoscaler *)
            hpa = {
                "apiVersion" -> "autoscaling/v2",
                "kind" -> "HorizontalPodAutoscaler",
                "metadata" -> {
                    "name" -> "api-hpa",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "scaleTargetRef" -> {
                        "apiVersion" -> "apps/v1",
                        "kind" -> "Deployment",
                        "name" -> "api"
                    },
                    "minReplicas" -> 2,
                    "maxReplicas" -> 10,
                    "metrics" -> {
                        {
                            "type" -> "Resource",
                            "resource" -> {
                                "name" -> "cpu",
                                "target" -> {"type" -> "Utilization", "averageUtilization" -> 70}
                            }
                        },
                        {
                            "type" -> "Resource",
                            "resource" -> {
                                "name" -> "memory",
                                "target" -> {"type" -> "Utilization", "averageUtilization" -> 80}
                            }
                        }
                    }
                }
            };
            
            (* Pod Disruption Budget *)
            podDisruptionBudget = {
                "apiVersion" -> "policy/v1",
                "kind" -> "PodDisruptionBudget",
                "metadata" -> {
                    "name" -> "api-pdb",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "minAvailable" -> 1,
                    "selector" -> {"matchLabels" -> {"app" -> "api"}}
                }
            };
            
            (* Apply all resources *)
            KubernetesService["apply", JSONStringify[deployment]];
            KubernetesService["apply", JSONStringify[service]];
            KubernetesService["apply", JSONStringify[hpa]];
            KubernetesService["apply", JSONStringify[podDisruptionBudget]];
            
            Log["INFO", "API service deployed with auto-scaling"];
            {
                "deployment" -> deployment,
                "service" -> service,
                "hpa" -> hpa,
                "pdb" -> podDisruptionBudget
            }
        ]
    ],
    
    (* Deploy worker service for background jobs *)
    "deployWorkerService" -> Function[{},
        Module[{deployment},
            Log["INFO", "Deploying worker service"];
            
            deployment = {
                "apiVersion" -> "apps/v1",
                "kind" -> "Deployment",
                "metadata" -> {
                    "name" -> "worker",
                    "namespace" -> clusterConfig["namespace"],
                    "labels" -> {"app" -> "worker"}
                },
                "spec" -> {
                    "replicas" -> serviceConfig["worker"]["replicas"],
                    "selector" -> {"matchLabels" -> {"app" -> "worker"}},
                    "template" -> {
                        "metadata" -> {"labels" -> {"app" -> "worker"}},
                        "spec" -> {
                            "containers" -> {{
                                "name" -> "worker",
                                "image" -> registryConfig["registry"] <> "/" <> registryConfig["imageTags"]["worker"],
                                "env" -> {
                                    {"name" -> "WORKER_QUEUES", "value" -> StringJoin[serviceConfig["worker"]["queues"], ","]},
                                    {"name" -> "DATABASE_URL", "valueFrom" -> {
                                        "secretKeyRef" -> {"name" -> "db-secret", "key" -> "url"}
                                    }},
                                    {"name" -> "REDIS_URL", "value" -> "redis://redis-service:6379"}
                                },
                                "resources" -> {
                                    "requests" -> {
                                        "cpu" -> serviceConfig["worker"]["cpu"],
                                        "memory" -> serviceConfig["worker"]["memory"]
                                    },
                                    "limits" -> {
                                        "cpu" -> "2000m",
                                        "memory" -> "2Gi"
                                    }
                                }
                            }},
                            "imagePullSecrets" -> {{"name" -> "registry-secret"}}
                        }
                    }
                }
            };
            
            KubernetesService["apply", JSONStringify[deployment]];
            
            Log["INFO", "Worker service deployed"];
            {"deployment" -> deployment}
        ]
    ],
    
    (* Deploy ingress for external access *)
    "deployIngress" -> Function[{},
        Module[{ingress},
            Log["INFO", "Deploying ingress controller"];
            
            ingress = {
                "apiVersion" -> "networking.k8s.io/v1",
                "kind" -> "Ingress",
                "metadata" -> {
                    "name" -> "api-ingress",
                    "namespace" -> clusterConfig["namespace"],
                    "annotations" -> {
                        "kubernetes.io/ingress.class" -> "nginx",
                        "cert-manager.io/cluster-issuer" -> "letsencrypt-prod",
                        "nginx.ingress.kubernetes.io/rate-limit" -> "100",
                        "nginx.ingress.kubernetes.io/rate-limit-window" -> "1m"
                    }
                },
                "spec" -> {
                    "tls" -> {{
                        "hosts" -> {"api.lyra-ecommerce.com"},
                        "secretName" -> "api-tls-secret"
                    }},
                    "rules" -> {{
                        "host" -> "api.lyra-ecommerce.com",
                        "http" -> {
                            "paths" -> {{
                                "path" -> "/",
                                "pathType" -> "Prefix",
                                "backend" -> {
                                    "service" -> {
                                        "name" -> "api-service",
                                        "port" -> {"number" -> 80}
                                    }
                                }
                            }}
                        }
                    }}
                }
            };
            
            KubernetesService["apply", JSONStringify[ingress]];
            
            Log["INFO", "Ingress deployed"];
            ingress
        ]
    ]
};

(* =========================== CLOUD STORAGE INTEGRATION =========================== *)

(* Multi-cloud storage abstraction *)
CloudStorageManager[provider_String] := {
    (* Upload file to cloud storage *)
    "uploadFile" -> Function[{localPath, remotePath, metadata},
        Switch[provider,
            "aws",
            Module[{result},
                result = CloudUpload[localPath, "s3://lyra-assets/" <> remotePath, "metadata" -> metadata];
                If[result["success"],
                    Log["INFO", "File uploaded to S3: " <> remotePath];
                    {"url" -> result["url"], "etag" -> result["etag"]}
                ,
                    ThrowError["S3 upload failed: " <> result["error"]]
                ]
            ],
            
            "azure",
            Module[{result},
                result = CloudUpload[localPath, "azure://lyraassets/" <> remotePath, "metadata" -> metadata];
                If[result["success"],
                    Log["INFO", "File uploaded to Azure Blob: " <> remotePath];
                    {"url" -> result["url"], "etag" -> result["etag"]}
                ,
                    ThrowError["Azure upload failed: " <> result["error"]]
                ]
            ],
            
            "gcp",
            Module[{result},
                result = CloudUpload[localPath, "gs://lyra-assets/" <> remotePath, "metadata" -> metadata];
                If[result["success"],
                    Log["INFO", "File uploaded to GCS: " <> remotePath];
                    {"url" -> result["url"], "etag" -> result["etag"]}
                ,
                    ThrowError["GCS upload failed: " <> result["error"]]
                ]
            ],
            
            _, ThrowError["Unsupported cloud provider: " <> provider]
        ]
    ],
    
    (* Download file from cloud storage *)
    "downloadFile" -> Function[{remotePath, localPath},
        Switch[provider,
            "aws", CloudDownload["s3://lyra-assets/" <> remotePath, localPath],
            "azure", CloudDownload["azure://lyraassets/" <> remotePath, localPath],
            "gcp", CloudDownload["gs://lyra-assets/" <> remotePath, localPath],
            _, ThrowError["Unsupported cloud provider: " <> provider]
        ]
    ],
    
    (* List files in cloud storage *)
    "listFiles" -> Function[prefix,
        Switch[provider,
            "aws", CloudList["s3://lyra-assets/" <> prefix],
            "azure", CloudList["azure://lyraassets/" <> prefix],
            "gcp", CloudList["gs://lyra-assets/" <> prefix],
            _, ThrowError["Unsupported cloud provider: " <> provider]
        ]
    ],
    
    (* Generate presigned URL for temporary access *)
    "generatePresignedURL" -> Function[{remotePath, expiration},
        Switch[provider,
            "aws", CloudPresignedURL["s3://lyra-assets/" <> remotePath, "expiration" -> expiration],
            "azure", CloudPresignedURL["azure://lyraassets/" <> remotePath, "expiration" -> expiration],
            "gcp", CloudPresignedURL["gs://lyra-assets/" <> remotePath, "expiration" -> expiration],
            _, ThrowError["Unsupported cloud provider: " <> provider]
        ]
    ],
    
    (* Batch upload with parallel processing *)
    "batchUpload" -> Function[fileList,
        Module[{pool, futures, results},
            pool = ThreadPool[8];
            
            futures = Map[
                Function[{localPath, remotePath},
                    pool.submit(this["uploadFile"], localPath, remotePath, {})
                ],
                fileList
            ];
            
            results = ParallelMap[Await, futures];
            
            Log["INFO", "Batch upload completed: " <> ToString[Length[results]] <> " files"];
            results
        ]
    ]
};

(* =========================== MICROSERVICES COMMUNICATION =========================== *)

(* Service mesh configuration *)
ServiceMesh[] := {
    (* Deploy Istio service mesh *)
    "deployIstio" -> Function[{},
        Module[{istioConfig},
            Log["INFO", "Deploying Istio service mesh"];
            
            (* Istio Gateway *)
            gateway = {
                "apiVersion" -> "networking.istio.io/v1beta1",
                "kind" -> "Gateway",
                "metadata" -> {
                    "name" -> "api-gateway",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "selector" -> {"istio" -> "ingressgateway"},
                    "servers" -> {{
                        "port" -> {"number" -> 80, "name" -> "http", "protocol" -> "HTTP"},
                        "hosts" -> {"api.lyra-ecommerce.com"}
                    }}
                }
            };
            
            (* Virtual Service *)
            virtualService = {
                "apiVersion" -> "networking.istio.io/v1beta1",
                "kind" -> "VirtualService",
                "metadata" -> {
                    "name" -> "api-vs",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "hosts" -> {"api.lyra-ecommerce.com"},
                    "gateways" -> {"api-gateway"},
                    "http" -> {{
                        "match" -> {{"uri" -> {"prefix" -> "/api/"}}},
                        "route" -> {{"destination" -> {"host" -> "api-service", "port" -> {"number" -> 80}}}},
                        "fault" -> {
                            "delay" -> {"percentage" -> {"value" -> 0.1}, "fixedDelay" -> "1s"},
                            "abort" -> {"percentage" -> {"value" -> 0.01}, "httpStatus" -> 500}
                        },
                        "retries" -> {"attempts" -> 3, "perTryTimeout" -> "2s"}
                    }}
                }
            };
            
            (* Destination Rule *)
            destinationRule = {
                "apiVersion" -> "networking.istio.io/v1beta1",
                "kind" -> "DestinationRule",
                "metadata" -> {
                    "name" -> "api-dr",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "host" -> "api-service",
                    "trafficPolicy" -> {
                        "connectionPool" -> {
                            "tcp" -> {"maxConnections" -> 10},
                            "http" -> {"http1MaxPendingRequests" -> 10, "maxRequestsPerConnection" -> 2}
                        },
                        "circuitBreaker" -> {
                            "consecutiveGatewayErrors" -> 5,
                            "interval" -> "30s",
                            "baseEjectionTime" -> "30s",
                            "maxEjectionPercent" -> 50,
                            "minHealthPercent" -> 30
                        }
                    }
                }
            };
            
            (* Apply Istio configuration *)
            KubernetesService["apply", JSONStringify[gateway]];
            KubernetesService["apply", JSONStringify[virtualService]];
            KubernetesService["apply", JSONStringify[destinationRule]];
            
            Log["INFO", "Istio service mesh deployed"];
            {
                "gateway" -> gateway,
                "virtualService" -> virtualService,
                "destinationRule" -> destinationRule
            }
        ]
    ],
    
    (* Configure mutual TLS *)
    "configureMutualTLS" -> Function[{},
        Module[{peerAuthentication},
            peerAuthentication = {
                "apiVersion" -> "security.istio.io/v1beta1",
                "kind" -> "PeerAuthentication",
                "metadata" -> {
                    "name" -> "default",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "mtls" -> {"mode" -> "STRICT"}
                }
            };
            
            KubernetesService["apply", JSONStringify[peerAuthentication]];
            
            Log["INFO", "Mutual TLS configured"];
            peerAuthentication
        ]
    ]
};

(* =========================== MONITORING AND OBSERVABILITY =========================== *)

(* Deploy comprehensive monitoring stack *)
MonitoringStack[] := {
    (* Deploy Prometheus for metrics *)
    "deployPrometheus" -> Function[{},
        Module[{prometheusConfig, deployment, service},
            Log["INFO", "Deploying Prometheus"];
            
            (* Prometheus ConfigMap *)
            prometheusConfig = {
                "apiVersion" -> "v1",
                "kind" -> "ConfigMap",
                "metadata" -> {
                    "name" -> "prometheus-config",
                    "namespace" -> clusterConfig["namespace"]
                },
                "data" -> {
                    "prometheus.yml" -> "
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - 'alerts.yml'

scrape_configs:
  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
"
                }
            };
            
            KubernetesService["apply", JSONStringify[prometheusConfig]];
            
            (* Prometheus Deployment *)
            deployment = this["createPrometheusDeployment"][];
            service = this["createPrometheusService"][];
            
            Log["INFO", "Prometheus deployed"];
            {
                "config" -> prometheusConfig,
                "deployment" -> deployment,
                "service" -> service
            }
        ]
    ],
    
    (* Deploy Grafana for visualization *)
    "deployGrafana" -> Function[{},
        Module[{deployment, service, configMap},
            Log["INFO", "Deploying Grafana"];
            
            (* Grafana ConfigMap with dashboards *)
            configMap = {
                "apiVersion" -> "v1",
                "kind" -> "ConfigMap",
                "metadata" -> {
                    "name" -> "grafana-dashboards",
                    "namespace" -> clusterConfig["namespace"]
                },
                "data" -> {
                    "api-dashboard.json" -> this["getAPIDashboard"][],
                    "infrastructure-dashboard.json" -> this["getInfrastructureDashboard"][]
                }
            };
            
            KubernetesService["apply", JSONStringify[configMap]];
            
            (* Grafana Deployment and Service *)
            deployment = this["createGrafanaDeployment"][];
            service = this["createGrafanaService"][];
            
            Log["INFO", "Grafana deployed"];
            {
                "configMap" -> configMap,
                "deployment" -> deployment,
                "service" -> service
            }
        ]
    ],
    
    (* Deploy Jaeger for distributed tracing *)
    "deployJaeger" -> Function[{},
        Module[{deployment, service},
            Log["INFO", "Deploying Jaeger"];
            
            deployment = {
                "apiVersion" -> "apps/v1",
                "kind" -> "Deployment",
                "metadata" -> {
                    "name" -> "jaeger",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "replicas" -> 1,
                    "selector" -> {"matchLabels" -> {"app" -> "jaeger"}},
                    "template" -> {
                        "metadata" -> {"labels" -> {"app" -> "jaeger"}},
                        "spec" -> {
                            "containers" -> {{
                                "name" -> "jaeger",
                                "image" -> "jaegertracing/all-in-one:1.35",
                                "ports" -> {
                                    {"containerPort" -> 16686, "name" -> "ui"},
                                    {"containerPort" -> 14268, "name" -> "collector"}
                                },
                                "env" -> {
                                    {"name" -> "COLLECTOR_ZIPKIN_HTTP_PORT", "value" -> "9411"}
                                }
                            }}
                        }
                    }
                }
            };
            
            service = {
                "apiVersion" -> "v1",
                "kind" -> "Service",
                "metadata" -> {
                    "name" -> "jaeger-service",
                    "namespace" -> clusterConfig["namespace"]
                },
                "spec" -> {
                    "selector" -> {"app" -> "jaeger"},
                    "ports" -> {
                        {"port" -> 16686, "targetPort" -> 16686, "name" -> "ui"},
                        {"port" -> 14268, "targetPort" -> 14268, "name" -> "collector"}
                    }
                }
            };
            
            KubernetesService["apply", JSONStringify[deployment]];
            KubernetesService["apply", JSONStringify[service]];
            
            Log["INFO", "Jaeger deployed"];
            {"deployment" -> deployment, "service" -> service}
        ]
    ],
    
    (* Create alerting rules *)
    "createAlertingRules" -> Function[{},
        Module[{alertRules},
            alertRules = {
                "apiVersion" -> "v1",
                "kind" -> "ConfigMap",
                "metadata" -> {
                    "name" -> "prometheus-alerts",
                    "namespace" -> clusterConfig["namespace"]
                },
                "data" -> {
                    "alerts.yml" -> "
groups:
  - name: api.rules
    rules:
    - alert: APIHighLatency
      expr: histogram_quantile(0.95, http_request_duration_seconds_bucket{job='api'}) > 0.5
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: 'API high latency detected'
        description: '95th percentile latency is {{ $value }}s'
    
    - alert: APIHighErrorRate
      expr: rate(http_requests_total{job='api',status=~'5..'}[5m]) > 0.1
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: 'API high error rate detected'
        description: 'Error rate is {{ $value }} req/s'
    
    - alert: PodCrashLooping
      expr: rate(kube_pod_container_status_restarts_total[15m]) > 0
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: 'Pod {{ $labels.pod }} is crash looping'
        description: 'Pod has restarted {{ $value }} times in the last 15 minutes'
"
                }
            };
            
            KubernetesService["apply", JSONStringify[alertRules]];
            
            Log["INFO", "Alerting rules created"];
            alertRules
        ]
    ]
};

(* =========================== CONFIGURATION MANAGEMENT =========================== *)

(* Configuration and secrets management *)
ConfigManager[] := {
    (* Deploy application configuration *)
    "deployConfiguration" -> Function[{},
        Module[{configMap, secrets},
            Log["INFO", "Deploying configuration and secrets"];
            
            (* Application ConfigMap *)
            configMap = {
                "apiVersion" -> "v1",
                "kind" -> "ConfigMap",
                "metadata" -> {
                    "name" -> "app-config",
                    "namespace" -> clusterConfig["namespace"]
                },
                "data" -> {
                    "environment" -> clusterConfig["environment"],
                    "log_level" -> "INFO",
                    "metrics_enabled" -> "true",
                    "tracing_enabled" -> "true",
                    "cache_ttl" -> "3600",
                    "max_connections" -> "1000"
                }
            };
            
            (* Application Secrets *)
            secrets = {
                "apiVersion" -> "v1",
                "kind" -> "Secret",
                "metadata" -> {
                    "name" -> "app-secrets",
                    "namespace" -> clusterConfig["namespace"]
                },
                "type" -> "Opaque",
                "data" -> {
                    "jwt_secret" -> Base64Encode[Environment["JWT_SECRET"]],
                    "api_key" -> Base64Encode[Environment["API_KEY"]],
                    "database_password" -> Base64Encode[Environment["DB_PASSWORD"]]
                }
            };
            
            KubernetesService["apply", JSONStringify[configMap]];
            KubernetesService["apply", JSONStringify[secrets]];
            
            Log["INFO", "Configuration deployed"];
            {"configMap" -> configMap, "secrets" -> secrets}
        ]
    ],
    
    (* Update configuration with rolling restart *)
    "updateConfiguration" -> Function[{newConfig},
        Module[{configMap, result},
            Log["INFO", "Updating application configuration"];
            
            (* Update ConfigMap *)
            configMap = {
                "apiVersion" -> "v1",
                "kind" -> "ConfigMap",
                "metadata" -> {
                    "name" -> "app-config",
                    "namespace" -> clusterConfig["namespace"]
                },
                "data" -> newConfig
            };
            
            KubernetesService["apply", JSONStringify[configMap]];
            
            (* Trigger rolling restart *)
            result = RollingUpdate["api", clusterConfig["namespace"]];
            
            Log["INFO", "Configuration updated and services restarted"];
            result
        ]
    ]
};

(* =========================== MAIN DEPLOYMENT ORCHESTRATION =========================== *)

(* Main cloud deployment orchestration *)
DeployCloudNativeApplication[] := Module[
    {containerManager, kubernetesManager, storageManager, serviceMesh, 
     monitoring, configManager, deploymentResult, totalTime, startTime},
    
    startTime = AbsoluteTime[];
    
    Log["INFO", "=== STARTING CLOUD-NATIVE DEPLOYMENT ==="];
    
    Try[
        (* Initialize managers *)
        containerManager = ContainerManager[registryConfig["registry"]];
        kubernetesManager = KubernetesManager[cloudConfig];
        storageManager = CloudStorageManager[cloudConfig["provider"]];
        serviceMesh = ServiceMesh[];
        monitoring = MonitoringStack[];
        configManager = ConfigManager[];
        
        (* 1. Build and push container images *)
        Log["INFO", "Step 1: Building and pushing container images"];
        imageResults = containerManager["buildAllServices"][];
        
        (* 2. Deploy configuration *)
        Log["INFO", "Step 2: Deploying configuration and secrets"];
        configResults = configManager["deployConfiguration"][];
        
        (* 3. Deploy application to Kubernetes *)
        Log["INFO", "Step 3: Deploying application to Kubernetes"];
        k8sResults = kubernetesManager["deployApplication"][];
        
        (* 4. Configure service mesh *)
        Log["INFO", "Step 4: Configuring service mesh"];
        meshResults = serviceMesh["deployIstio"][];
        serviceMesh["configureMutualTLS"][];
        
        (* 5. Deploy monitoring stack *)
        Log["INFO", "Step 5: Deploying monitoring and observability"];
        prometheusResults = monitoring["deployPrometheus"][];
        grafanaResults = monitoring["deployGrafana"][];
        jaegerResults = monitoring["deployJaeger"][];
        monitoring["createAlertingRules"][];
        
        (* 6. Verify deployment *)
        Log["INFO", "Step 6: Verifying deployment"];
        healthCheck = this["verifyDeployment"][k8sResults];
        
        totalTime = AbsoluteTime[] - startTime;
        
        deploymentResult = {
            "status" -> "SUCCESS",
            "deploymentTime" -> totalTime,
            "images" -> imageResults,
            "kubernetes" -> k8sResults,
            "serviceMesh" -> meshResults,
            "monitoring" -> {
                "prometheus" -> prometheusResults,
                "grafana" -> grafanaResults,
                "jaeger" -> jaegerResults
            },
            "configuration" -> configResults,
            "healthCheck" -> healthCheck,
            "endpoints" -> {
                "api" -> "https://api.lyra-ecommerce.com",
                "grafana" -> "https://grafana.lyra-ecommerce.com",
                "jaeger" -> "https://jaeger.lyra-ecommerce.com"
            }
        };
        
        Log["INFO", "=== CLOUD-NATIVE DEPLOYMENT COMPLETE ==="];
        Log["INFO", "Total deployment time: " <> ToString[Round[totalTime / 60, 0.1]] <> " minutes"];
        
        deploymentResult
    ,
        error_ :> Module[{},
            Log["ERROR", "Deployment failed: " <> ToString[error]];
            {
                "status" -> "FAILED",
                "error" -> error,
                "deploymentTime" -> AbsoluteTime[] - startTime
            }
        ]
    ],
    
    (* Verify deployment health *)
    "verifyDeployment" -> Function[deploymentInfo,
        Module[{healthChecks, results},
            Log["INFO", "Running deployment health checks"];
            
            healthChecks = {
                "api_health" -> Function[{},
                    response = HTTPGet["https://api.lyra-ecommerce.com/health", "timeout" -> 10000];
                    response["status"] == 200
                ],
                
                "database_connectivity" -> Function[{},
                    result = KubernetesService["exec", "postgres", "pg_isready -U lyra"];
                    result["exitCode"] == 0
                ],
                
                "redis_connectivity" -> Function[{},
                    result = KubernetesService["exec", "redis", "redis-cli ping"];
                    StringContains[result["stdout"], "PONG"]
                ],
                
                "metrics_endpoint" -> Function[{},
                    response = HTTPGet["https://api.lyra-ecommerce.com/metrics", "timeout" -> 10000];
                    response["status"] == 200
                ]
            };
            
            results = Map[
                Function[{name, check},
                    Try[
                        {name -> check[]},
                        error_ :> {name -> False}
                    ]
                ],
                healthChecks
            ];
            
            allHealthy = AllTrue[Values[results]];
            
            Log["INFO", "Health check results: " <> ToString[results]];
            
            {
                "overall" -> allHealthy,
                "individual" -> results,
                "timestamp" -> Now[]
            }
        ]
    ]
];

(* =========================== DEPLOYMENT OPERATIONS =========================== *)

(* Production deployment operations *)
DeploymentOps[] := {
    (* Rolling update with zero downtime *)
    "rollingUpdate" -> Function[{serviceName, newImageTag},
        Module[{updateResult},
            Log["INFO", "Performing rolling update for " <> serviceName];
            
            updateResult = RollingUpdate[serviceName, clusterConfig["namespace"], 
                "image" -> newImageTag,
                "strategy" -> "RollingUpdate",
                "maxUnavailable" -> "25%",
                "maxSurge" -> "25%"
            ];
            
            If[updateResult["success"],
                Log["INFO", "Rolling update completed successfully"];
                updateResult
            ,
                Log["ERROR", "Rolling update failed: " <> updateResult["error"]];
                ThrowError["Rolling update failed"]
            ]
        ]
    ],
    
    (* Scale services based on demand *)
    "scaleService" -> Function[{serviceName, replicas},
        Module[{scaleResult},
            Log["INFO", "Scaling " <> serviceName <> " to " <> ToString[replicas] <> " replicas"];
            
            scaleResult = DeploymentScale[serviceName, clusterConfig["namespace"], replicas];
            
            If[scaleResult["success"],
                Log["INFO", "Service scaled successfully"];
                scaleResult
            ,
                ThrowError["Scaling failed: " <> scaleResult["error"]]
            ]
        ]
    ],
    
    (* Backup and disaster recovery *)
    "createBackup" -> Function[{},
        Module[{backupName, backupResult},
            backupName = "backup-" <> DateFormat[Now[], "YYYYMMDD-HHMMSS"];
            
            Log["INFO", "Creating backup: " <> backupName];
            
            (* Backup database *)
            dbBackup = this["backupDatabase"][backupName];
            
            (* Backup configuration *)
            configBackup = this["backupConfiguration"][backupName];
            
            (* Upload to cloud storage *)
            storageManager = CloudStorageManager[cloudConfig["provider"]];
            storageManager["uploadFile"][dbBackup, "backups/" <> backupName <> "/database.sql", {}];
            storageManager["uploadFile"][configBackup, "backups/" <> backupName <> "/config.json", {}];
            
            Log["INFO", "Backup created successfully: " <> backupName];
            {
                "backupName" -> backupName,
                "database" -> dbBackup,
                "configuration" -> configBackup,
                "timestamp" -> Now[]
            }
        ]
    ]
};

(* =========================== EXECUTION =========================== *)

(* Deploy the complete cloud-native application *)
cloudDeploymentResult = DeployCloudNativeApplication[];

(* Display deployment results *)
Print["Cloud-Native Deployment Results:"];
Print["Status: " <> cloudDeploymentResult["status"]];

If[cloudDeploymentResult["status"] == "SUCCESS",
    Print["Deployment Time: " <> ToString[Round[cloudDeploymentResult["deploymentTime"] / 60, 0.1]] <> " minutes"];
    Print[""];
    Print["Endpoints:"];
    Print["  API: " <> cloudDeploymentResult["endpoints"]["api"]];
    Print["  Grafana: " <> cloudDeploymentResult["endpoints"]["grafana"]];
    Print["  Jaeger: " <> cloudDeploymentResult["endpoints"]["jaeger"]];
    Print[""];
    Print["Services Deployed:"];
    Print["  - PostgreSQL Database with persistent storage"];
    Print["  - Redis for caching and session storage"];
    Print["  - API service with auto-scaling (2-10 replicas)"];
    Print["  - Background worker service"];
    Print["  - Istio service mesh with mTLS"];
    Print["  - Prometheus + Grafana monitoring"];
    Print["  - Jaeger distributed tracing"];
    Print["  - Load balancer with SSL termination"];
    Print[""];
    Print["Health Check: " <> ToString[cloudDeploymentResult["healthCheck"]["overall"]]];
,
    Print["Error: " <> ToString[cloudDeploymentResult["error"]]];
];

(* Example output:
Cloud-Native Deployment Results:
Status: SUCCESS
Deployment Time: 23.7 minutes

Endpoints:
  API: https://api.lyra-ecommerce.com
  Grafana: https://grafana.lyra-ecommerce.com
  Jaeger: https://jaeger.lyra-ecommerce.com

Services Deployed:
  - PostgreSQL Database with persistent storage
  - Redis for caching and session storage
  - API service with auto-scaling (2-10 replicas)
  - Background worker service
  - Istio service mesh with mTLS
  - Prometheus + Grafana monitoring
  - Jaeger distributed tracing
  - Load balancer with SSL termination

Health Check: True
*)
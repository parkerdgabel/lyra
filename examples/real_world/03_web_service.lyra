(*
==============================================================================
WEB SERVICE & API INTEGRATION - MODERN WEB DEVELOPMENT
==============================================================================

A comprehensive web service demonstrating Lyra's web development capabilities:
- HTTP server with RESTful API endpoints
- API client for external service integration
- JSON processing and validation
- WebSocket real-time communication
- Authentication and security
- Database integration
- Load balancing and monitoring

This example builds a complete e-commerce API service with real-time features,
external payment processing, and production-ready monitoring.
==============================================================================
*)

(* =========================== CONFIGURATION =========================== *)

(* Server configuration *)
serverConfig = {
    "host" -> "0.0.0.0",
    "port" -> 8080,
    "workers" -> 4,
    "maxConnections" -> 1000,
    "requestTimeout" -> 30000,
    "enableHTTPS" -> True,
    "tlsCertPath" -> "/etc/ssl/server.crt",
    "tlsKeyPath" -> "/etc/ssl/server.key",
    "corsOrigins" -> {"http://localhost:3000", "https://myapp.com"}
};

(* Database configuration *)
dbConfig = {
    "host" -> "localhost",
    "port" -> 5432,
    "database" -> "ecommerce",
    "username" -> Environment["DB_USERNAME"],
    "password" -> Environment["DB_PASSWORD"],
    "poolSize" -> 20,
    "maxRetries" -> 3
};

(* External service configurations *)
externalServices = {
    "paymentGateway" -> {
        "baseUrl" -> "https://api.stripe.com/v1",
        "apiKey" -> Environment["STRIPE_API_KEY"],
        "timeout" -> 15000
    },
    "emailService" -> {
        "baseUrl" -> "https://api.sendgrid.com/v3",
        "apiKey" -> Environment["SENDGRID_API_KEY"]
    },
    "inventoryService" -> {
        "baseUrl" -> "http://inventory-service:8081",
        "timeout" -> 5000,
        "retries" -> 3
    }
};

(* Security configuration *)
securityConfig = {
    "jwtSecret" -> Environment["JWT_SECRET"],
    "jwtExpiry" -> 86400, (* 24 hours *)
    "rateLimitWindow" -> 900, (* 15 minutes *)
    "rateLimitRequests" -> 100,
    "enableCORS" -> True,
    "enableCSRF" -> True
};

(* =========================== DATABASE LAYER =========================== *)

(* Database connection and query handling *)
DatabaseManager[config_Association] := Module[
    {connectionPool, queryCache},
    
    connectionPool = CreateConnectionPool[config];
    queryCache = CreateCache["maxSize" -> 1000, "ttl" -> 300];
    
    {
        (* Execute query with connection pooling *)
        "query" -> Function[{sql, params},
            Module[{connection, result},
                connection = connectionPool.GetConnection[];
                
                Try[
                    result = connection.Execute[sql, params];
                    connectionPool.ReturnConnection[connection];
                    result
                ,
                    error_ :> Module[{},
                        connectionPool.ReturnConnection[connection];
                        ThrowError["Database query failed: " <> ToString[error]]
                    ]
                ]
            ]
        ],
        
        (* Cached query execution *)
        "cachedQuery" -> Function[{sql, params, cacheKey},
            Module[{cached, result},
                cached = queryCache.Get[cacheKey];
                If[cached =!= Missing,
                    cached
                ,
                    result = this["query"][sql, params];
                    queryCache.Set[cacheKey, result];
                    result
                ]
            ]
        ],
        
        (* Transaction support *)
        "transaction" -> Function[operations,
            Module[{connection, result},
                connection = connectionPool.GetConnection[];
                connection.BeginTransaction[];
                
                Try[
                    result = Map[#[connection] &, operations];
                    connection.CommitTransaction[];
                    connectionPool.ReturnConnection[connection];
                    result
                ,
                    error_ :> Module[{},
                        connection.RollbackTransaction[];
                        connectionPool.ReturnConnection[connection];
                        ThrowError["Transaction failed: " <> ToString[error]]
                    ]
                ]
            ]
        ]
    }
];

(* Product model with CRUD operations *)
ProductModel[db_] := {
    "create" -> Function[productData,
        Module[{sql, result},
            sql = "INSERT INTO products (name, description, price, category_id, stock_quantity) VALUES ($1, $2, $3, $4, $5) RETURNING *";
            result = db["query"][sql, {
                productData["name"],
                productData["description"],
                productData["price"],
                productData["categoryId"],
                productData["stock"]
            }];
            First[result]
        ]
    ],
    
    "findById" -> Function[productId,
        Module[{sql, result},
            sql = "SELECT p.*, c.name as category_name FROM products p LEFT JOIN categories c ON p.category_id = c.id WHERE p.id = $1";
            result = db["cachedQuery"][sql, {productId}, "product_" <> ToString[productId]];
            If[Length[result] > 0, First[result], Missing]
        ]
    ],
    
    "findAll" -> Function[{limit, offset, filters},
        Module[{sql, params, whereClause},
            whereClause = If[Length[filters] > 0,
                "WHERE " <> StringJoin[
                    Map[# <> " = ?" &, Keys[filters]], 
                    " AND "
                ],
                ""
            ];
            
            sql = "SELECT p.*, c.name as category_name FROM products p LEFT JOIN categories c ON p.category_id = c.id " <>
                  whereClause <> " ORDER BY p.created_at DESC LIMIT $" <> ToString[Length[filters] + 1] <> 
                  " OFFSET $" <> ToString[Length[filters] + 2];
            
            params = Join[Values[filters], {limit, offset}];
            db["query"][sql, params]
        ]
    ],
    
    "update" -> Function[{productId, updates},
        Module[{sql, setClauses, params},
            setClauses = Map[# <> " = $" <> ToString[Position[Keys[updates], #][[1, 1]] + 1] &, Keys[updates]];
            sql = "UPDATE products SET " <> StringJoin[setClauses, ", "] <> " WHERE id = $1 RETURNING *";
            params = Prepend[Values[updates], productId];
            
            result = db["query"][sql, params];
            If[Length[result] > 0, First[result], Missing]
        ]
    ],
    
    "delete" -> Function[productId,
        Module[{sql},
            sql = "DELETE FROM products WHERE id = $1";
            db["query"][sql, {productId}];
            True
        ]
    ],
    
    "updateStock" -> Function[{productId, quantity},
        Module[{sql},
            sql = "UPDATE products SET stock_quantity = stock_quantity + $1 WHERE id = $2 AND stock_quantity + $1 >= 0 RETURNING stock_quantity";
            result = db["query"][sql, {quantity, productId}];
            If[Length[result] > 0, First[result]["stock_quantity"], Missing]
        ]
    ]
};

(* =========================== AUTHENTICATION & SECURITY =========================== *)

(* JWT authentication middleware *)
AuthMiddleware[config_Association] := {
    "generateToken" -> Function[userData,
        Module[{payload, token},
            payload = {
                "userId" -> userData["id"],
                "email" -> userData["email"],
                "role" -> userData["role"],
                "exp" -> UnixTimestamp[] + config["jwtExpiry"],
                "iat" -> UnixTimestamp[]
            };
            
            token = JWTSign[payload, config["jwtSecret"], "HS256"];
            token
        ]
    ],
    
    "verifyToken" -> Function[token,
        Try[
            payload = JWTVerify[token, config["jwtSecret"]];
            
            (* Check expiration *)
            If[payload["exp"] < UnixTimestamp[],
                ThrowError["Token expired"]
            ];
            
            payload
        ,
            error_ :> Missing
        ]
    ],
    
    "requireAuth" -> Function[{request, response, next},
        Module[{authHeader, token, payload},
            authHeader = request["headers"]["Authorization"];
            
            If[StringStartsWith[authHeader, "Bearer "],
                token = StringDrop[authHeader, 7];
                payload = this["verifyToken"][token];
                
                If[payload =!= Missing,
                    request["user"] = payload;
                    next[]
                ,
                    response.Status[401].JSON[{"error" -> "Invalid token"}]
                ]
            ,
                response.Status[401].JSON[{"error" -> "Authorization header required"}]
            ]
        ]
    ],
    
    "requireRole" -> Function[requiredRole,
        Function[{request, response, next},
            If[request["user"]["role"] == requiredRole,
                next[]
            ,
                response.Status[403].JSON[{"error" -> "Insufficient permissions"}]
            ]
        ]
    ]
};

(* Rate limiting middleware *)
RateLimiter[config_Association] := Module[
    {requestCounts, cleanupTask},
    
    requestCounts = CreateCache["maxSize" -> 10000];
    
    (* Cleanup task to remove old entries *)
    cleanupTask = ScheduledTask[
        Function[{},
            Module[{cutoff},
                cutoff = UnixTimestamp[] - config["rateLimitWindow"];
                requestCounts.RemoveIf[Function[{key, value}, value["timestamp"] < cutoff]];
            ]
        ],
        300 (* Clean up every 5 minutes *)
    ];
    
    Function[{request, response, next},
        Module[{clientIp, key, current, now},
            clientIp = request["headers"]["X-Forwarded-For"] || request["remoteAddress"];
            key = "rate_limit_" <> clientIp;
            now = UnixTimestamp[];
            
            current = requestCounts.Get[key];
            
            If[current === Missing,
                requestCounts.Set[key, {"count" -> 1, "timestamp" -> now}];
                next[]
            ,
                If[now - current["timestamp"] > config["rateLimitWindow"],
                    (* Reset window *)
                    requestCounts.Set[key, {"count" -> 1, "timestamp" -> now}];
                    next[]
                ,
                    If[current["count"] >= config["rateLimitRequests"],
                        response.Status[429].JSON[{
                            "error" -> "Rate limit exceeded",
                            "retryAfter" -> config["rateLimitWindow"] - (now - current["timestamp"])
                        }]
                    ,
                        requestCounts.Set[key, {
                            "count" -> current["count"] + 1,
                            "timestamp" -> current["timestamp"]
                        }];
                        next[]
                    ]
                ]
            ]
        ]
    ]
];

(* =========================== EXTERNAL SERVICE INTEGRATION =========================== *)

(* Payment service integration *)
PaymentService[config_Association] := {
    "createPaymentIntent" -> Function[{amount, currency, metadata},
        Module[{requestData, response},
            requestData = {
                "amount" -> amount * 100, (* Convert to cents *)
                "currency" -> currency,
                "automatic_payment_methods" -> {"enabled" -> True},
                "metadata" -> metadata
            };
            
            response = HTTPPost[
                config["baseUrl"] <> "/payment_intents",
                "headers" -> {
                    "Authorization" -> "Bearer " <> config["apiKey"],
                    "Content-Type" -> "application/json"
                },
                "body" -> JSONStringify[requestData],
                "timeout" -> config["timeout"]
            ];
            
            If[response["status"] == 200,
                JSONParse[response["body"]]
            ,
                ThrowError["Payment intent creation failed: " <> response["body"]]
            ]
        ]
    ],
    
    "confirmPayment" -> Function[paymentIntentId,
        Module[{response},
            response = HTTPPost[
                config["baseUrl"] <> "/payment_intents/" <> paymentIntentId <> "/confirm",
                "headers" -> {
                    "Authorization" -> "Bearer " <> config["apiKey"]
                },
                "timeout" -> config["timeout"]
            ];
            
            If[response["status"] == 200,
                JSONParse[response["body"]]
            ,
                ThrowError["Payment confirmation failed: " <> response["body"]]
            ]
        ]
    ],
    
    "retrievePayment" -> Function[paymentIntentId,
        Module[{response},
            response = HTTPGet[
                config["baseUrl"] <> "/payment_intents/" <> paymentIntentId,
                "headers" -> {
                    "Authorization" -> "Bearer " <> config["apiKey"]
                },
                "timeout" -> config["timeout"]
            ];
            
            If[response["status"] == 200,
                JSONParse[response["body"]]
            ,
                Missing
            ]
        ]
    ]
};

(* Email notification service *)
EmailService[config_Association] := {
    "sendTransactionalEmail" -> Function[{to, templateId, data},
        Module[{requestData, response},
            requestData = {
                "personalizations" -> {{
                    "to" -> {{"email" -> to}},
                    "dynamic_template_data" -> data
                }},
                "template_id" -> templateId
            };
            
            response = HTTPPost[
                config["baseUrl"] <> "/mail/send",
                "headers" -> {
                    "Authorization" -> "Bearer " <> config["apiKey"],
                    "Content-Type" -> "application/json"
                },
                "body" -> JSONStringify[requestData]
            ];
            
            response["status"] == 202
        ]
    ],
    
    "sendOrderConfirmation" -> Function[{email, orderData},
        this["sendTransactionalEmail"][email, "order_confirmation", orderData]
    ],
    
    "sendShippingNotification" -> Function[{email, shippingData},
        this["sendTransactionalEmail"][email, "shipping_notification", shippingData]
    ]
};

(* =========================== REST API ENDPOINTS =========================== *)

(* Product API endpoints *)
ProductAPI[db_, auth_] := {
    (* GET /api/products *)
    "getProducts" -> Function[{request, response},
        Module[{limit, offset, category, products, total},
            limit = Min[ToExpression[request["query"]["limit"] || "20"], 100];
            offset = ToExpression[request["query"]["offset"] || "0"];
            category = request["query"]["category"];
            
            filters = If[category =!= Missing, {"category_id" -> category}, {}];
            products = ProductModel[db]["findAll"][limit, offset, filters];
            
            total = db["query"]["SELECT COUNT(*) as count FROM products", {}];
            
            response.JSON[{
                "products" -> products,
                "pagination" -> {
                    "limit" -> limit,
                    "offset" -> offset,
                    "total" -> First[total]["count"]
                }
            }]
        ]
    ],
    
    (* GET /api/products/:id *)
    "getProduct" -> Function[{request, response},
        Module[{productId, product},
            productId = ToExpression[request["params"]["id"]];
            product = ProductModel[db]["findById"][productId];
            
            If[product =!= Missing,
                response.JSON[product]
            ,
                response.Status[404].JSON[{"error" -> "Product not found"}]
            ]
        ]
    ],
    
    (* POST /api/products *)
    "createProduct" -> Function[{request, response},
        Module[{productData, validation, product},
            productData = JSONParse[request["body"]];
            
            (* Validate required fields *)
            validation = ValidateProductData[productData];
            If[validation["valid"] === False,
                response.Status[400].JSON[{"error" -> "Validation failed", "details" -> validation["errors"]}];
                Return[]
            ];
            
            Try[
                product = ProductModel[db]["create"][productData];
                response.Status[201].JSON[product]
            ,
                error_ :> response.Status[500].JSON[{"error" -> "Failed to create product"}]
            ]
        ]
    ],
    
    (* PUT /api/products/:id *)
    "updateProduct" -> Function[{request, response},
        Module[{productId, updates, product},
            productId = ToExpression[request["params"]["id"]];
            updates = JSONParse[request["body"]];
            
            (* Validate updates *)
            validation = ValidateProductData[updates, "partial" -> True];
            If[validation["valid"] === False,
                response.Status[400].JSON[{"error" -> "Validation failed", "details" -> validation["errors"]}];
                Return[]
            ];
            
            Try[
                product = ProductModel[db]["update"][productId, updates];
                If[product =!= Missing,
                    response.JSON[product]
                ,
                    response.Status[404].JSON[{"error" -> "Product not found"}]
                ]
            ,
                error_ :> response.Status[500].JSON[{"error" -> "Failed to update product"}]
            ]
        ]
    ],
    
    (* DELETE /api/products/:id *)
    "deleteProduct" -> Function[{request, response},
        Module[{productId},
            productId = ToExpression[request["params"]["id"]];
            
            Try[
                ProductModel[db]["delete"][productId];
                response.Status[204].Send[]
            ,
                error_ :> response.Status[500].JSON[{"error" -> "Failed to delete product"}]
            ]
        ]
    ]
};

(* Order processing API *)
OrderAPI[db_, paymentService_, emailService_, auth_] := {
    (* POST /api/orders *)
    "createOrder" -> Function[{request, response},
        Module[{orderData, validation, paymentIntent, order, emailSent},
            orderData = JSONParse[request["body"]];
            orderData["userId"] = request["user"]["userId"];
            
            (* Validate order *)
            validation = ValidateOrderData[orderData];
            If[validation["valid"] === False,
                response.Status[400].JSON[{"error" -> "Invalid order data", "details" -> validation["errors"]}];
                Return[]
            ];
            
            (* Process order in transaction *)
            Try[
                order = db["transaction"][{
                    (* Create order record *)
                    Function[conn,
                        conn.Execute[
                            "INSERT INTO orders (user_id, total_amount, status) VALUES ($1, $2, $3) RETURNING *",
                            {orderData["userId"], orderData["totalAmount"], "pending"}
                        ]
                    ],
                    
                    (* Create order items *)
                    Function[conn,
                        Map[
                            Function[item,
                                conn.Execute[
                                    "INSERT INTO order_items (order_id, product_id, quantity, price) VALUES ($1, $2, $3, $4)",
                                    {order["id"], item["productId"], item["quantity"], item["price"]}
                                ]
                            ],
                            orderData["items"]
                        ]
                    ],
                    
                    (* Update inventory *)
                    Function[conn,
                        Map[
                            Function[item,
                                newStock = ProductModel[db]["updateStock"][item["productId"], -item["quantity"]];
                                If[newStock === Missing,
                                    ThrowError["Insufficient inventory for product " <> ToString[item["productId"]]]
                                ]
                            ],
                            orderData["items"]
                        ]
                    ]
                }];
                
                (* Create payment intent *)
                paymentIntent = paymentService["createPaymentIntent"][
                    orderData["totalAmount"],
                    "usd",
                    {"orderId" -> ToString[order["id"]]}
                ];
                
                (* Send confirmation email *)
                emailService["sendOrderConfirmation"][
                    request["user"]["email"],
                    Join[order, {"paymentIntent" -> paymentIntent}]
                ];
                
                response.Status[201].JSON[{
                    "order" -> order,
                    "paymentIntent" -> paymentIntent
                }]
            ,
                error_ :> response.Status[500].JSON[{"error" -> "Failed to create order: " <> ToString[error]}]
            ]
        ]
    ],
    
    (* GET /api/orders/:id *)
    "getOrder" -> Function[{request, response},
        Module[{orderId, order},
            orderId = ToExpression[request["params"]["id"]];
            
            order = db["query"][
                "SELECT o.*, oi.product_id, oi.quantity, oi.price, p.name as product_name FROM orders o " <>
                "LEFT JOIN order_items oi ON o.id = oi.order_id " <>
                "LEFT JOIN products p ON oi.product_id = p.id " <>
                "WHERE o.id = $1 AND o.user_id = $2",
                {orderId, request["user"]["userId"]}
            ];
            
            If[Length[order] > 0,
                response.JSON[GroupOrderItems[order]]
            ,
                response.Status[404].JSON[{"error" -> "Order not found"}]
            ]
        ]
    ],
    
    (* GET /api/orders *)
    "getUserOrders" -> Function[{request, response},
        Module[{orders},
            orders = db["query"][
                "SELECT * FROM orders WHERE user_id = $1 ORDER BY created_at DESC",
                {request["user"]["userId"]}
            ];
            
            response.JSON[{"orders" -> orders}]
        ]
    ]
};

(* =========================== WEBSOCKET REAL-TIME FEATURES =========================== *)

(* WebSocket manager for real-time features *)
WebSocketManager[] := Module[
    {connections, rooms, eventHandlers},
    
    connections = CreateCache["maxSize" -> 10000];
    rooms = {};
    eventHandlers = {};
    
    {
        "addConnection" -> Function[{connectionId, websocket, userId},
            connections.Set[connectionId, {
                "websocket" -> websocket,
                "userId" -> userId,
                "connectedAt" -> Now[]
            }];
            
            Log["INFO", "WebSocket connection added: " <> connectionId];
        ],
        
        "removeConnection" -> Function[connectionId,
            connections.Remove[connectionId];
            Log["INFO", "WebSocket connection removed: " <> connectionId];
        ],
        
        "joinRoom" -> Function[{connectionId, roomName},
            If[!MemberQ[rooms, roomName],
                AppendTo[rooms, roomName -> {}]
            ];
            
            AppendTo[rooms[roomName], connectionId];
        ],
        
        "leaveRoom" -> Function[{connectionId, roomName},
            If[MemberQ[rooms, roomName],
                rooms[roomName] = DeleteCases[rooms[roomName], connectionId]
            ]
        ],
        
        "broadcastToRoom" -> Function[{roomName, message},
            If[MemberQ[rooms, roomName],
                Map[
                    Function[connectionId,
                        connection = connections.Get[connectionId];
                        If[connection =!= Missing,
                            connection["websocket"].Send[JSONStringify[message]]
                        ]
                    ],
                    rooms[roomName]
                ]
            ]
        ],
        
        "sendToUser" -> Function[{userId, message},
            Map[
                Function[{connectionId, connection},
                    If[connection["userId"] == userId,
                        connection["websocket"].Send[JSONStringify[message]]
                    ]
                ],
                connections.GetAll[]
            ]
        ],
        
        "handleMessage" -> Function[{connectionId, message},
            Module[{parsedMessage, handler},
                parsedMessage = JSONParse[message];
                handler = eventHandlers[parsedMessage["type"]];
                
                If[handler =!= Missing,
                    handler[connectionId, parsedMessage["data"]]
                ,
                    Log["WARN", "No handler for message type: " <> parsedMessage["type"]]
                ]
            ]
        ],
        
        "registerHandler" -> Function[{eventType, handler},
            eventHandlers[eventType] = handler;
        ]
    }
];

(* Real-time order tracking *)
OrderTrackingWS[wsManager_, db_] := Module[{},
    (* Register event handlers *)
    wsManager["registerHandler"]["subscribe_order", 
        Function[{connectionId, data},
            wsManager["joinRoom"][connectionId, "order_" <> ToString[data["orderId"]]]
        ]
    ];
    
    wsManager["registerHandler"]["unsubscribe_order",
        Function[{connectionId, data},
            wsManager["leaveRoom"][connectionId, "order_" <> ToString[data["orderId"]]]
        ]
    ];
    
    (* Function to broadcast order updates *)
    Function[{orderId, status, details},
        wsManager["broadcastToRoom"]["order_" <> ToString[orderId], {
            "type" -> "order_update",
            "orderId" -> orderId,
            "status" -> status,
            "details" -> details,
            "timestamp" -> Now[]
        }]
    ]
];

(* =========================== SERVER SETUP =========================== *)

(* Main HTTP server setup *)
CreateWebServer[config_Association, db_, services_Association] := Module[
    {server, auth, rateLimiter, wsManager, orderTracking},
    
    Log["INFO", "Creating web server"];
    
    (* Initialize middleware *)
    auth = AuthMiddleware[securityConfig];
    rateLimiter = RateLimiter[securityConfig];
    wsManager = WebSocketManager[];
    orderTracking = OrderTrackingWS[wsManager, db];
    
    (* Initialize API endpoints *)
    productAPI = ProductAPI[db, auth];
    orderAPI = OrderAPI[db, services["payment"], services["email"], auth];
    
    (* Create HTTP server *)
    server = HTTPServer[config["host"], config["port"]];
    
    (* Global middleware *)
    server.Use[LoggingMiddleware[]];
    server.Use[CORSMiddleware[config["corsOrigins"]]];
    server.Use[rateLimiter];
    server.Use[JSONParsingMiddleware[]];
    
    (* Authentication routes *)
    server.Post["/api/auth/login", AuthAPI["login"]];
    server.Post["/api/auth/register", AuthAPI["register"]];
    server.Post["/api/auth/refresh", AuthAPI["refreshToken"]];
    
    (* Protected product routes *)
    server.Get["/api/products", productAPI["getProducts"]];
    server.Get["/api/products/:id", productAPI["getProduct"]];
    server.Post["/api/products", auth["requireAuth"], auth["requireRole"]["admin"], productAPI["createProduct"]];
    server.Put["/api/products/:id", auth["requireAuth"], auth["requireRole"]["admin"], productAPI["updateProduct"]];
    server.Delete["/api/products/:id", auth["requireAuth"], auth["requireRole"]["admin"], productAPI["deleteProduct"]];
    
    (* Order routes *)
    server.Post["/api/orders", auth["requireAuth"], orderAPI["createOrder"]];
    server.Get["/api/orders/:id", auth["requireAuth"], orderAPI["getOrder"]];
    server.Get["/api/orders", auth["requireAuth"], orderAPI["getUserOrders"]];
    
    (* WebSocket endpoint *)
    server.WebSocket["/ws", 
        Function[websocket,
            Module[{connectionId, userId},
                connectionId = RandomString[16];
                userId = websocket["user"]["userId"]; (* From auth middleware *)
                
                wsManager["addConnection"][connectionId, websocket, userId];
                
                websocket.OnMessage[Function[message,
                    wsManager["handleMessage"][connectionId, message]
                ]];
                
                websocket.OnClose[Function[{},
                    wsManager["removeConnection"][connectionId]
                ]];
            ]
        ]
    ];
    
    (* Health check endpoint *)
    server.Get["/health", 
        Function[{request, response},
            response.JSON[{
                "status" -> "healthy",
                "timestamp" -> Now[],
                "uptime" -> server.GetUptime[],
                "connections" -> server.GetActiveConnections[]
            }]
        ]
    ];
    
    (* Metrics endpoint *)
    server.Get["/metrics",
        Function[{request, response},
            metrics = {
                "requests_total" -> server.GetRequestCount[],
                "response_time_avg" -> server.GetAverageResponseTime[],
                "active_connections" -> server.GetActiveConnections[],
                "memory_usage" -> MemoryUsage[],
                "cpu_usage" -> SystemInfo["CPUUsage"]
            };
            
            response.Text[PrometheusFormat[metrics], "content-type" -> "text/plain"]
        ]
    ];
    
    server
];

(* =========================== MONITORING & LOGGING =========================== *)

(* Request logging middleware *)
LoggingMiddleware[] := Function[{request, response, next},
    Module[{startTime, endTime, duration, logData},
        startTime = AbsoluteTime[];
        
        next[];
        
        endTime = AbsoluteTime[];
        duration = endTime - startTime;
        
        logData = {
            "method" -> request["method"],
            "path" -> request["path"],
            "status" -> response["status"],
            "duration" -> Round[duration * 1000, 0.1], (* ms *)
            "userAgent" -> request["headers"]["User-Agent"],
            "ip" -> request["remoteAddress"],
            "timestamp" -> DateFormat[Now[], "ISO"]
        };
        
        Log["INFO", "HTTP Request: " <> JSONStringify[logData]];
    ]
];

(* Application monitoring *)
AppMonitor[] := Module[
    {metrics, alerts},
    
    metrics = CreateCache["maxSize" -> 1000];
    alerts = {};
    
    (* Collect system metrics *)
    ScheduledTask[
        Function[{},
            Module[{systemMetrics},
                systemMetrics = {
                    "timestamp" -> Now[],
                    "cpu_usage" -> SystemInfo["CPUUsage"],
                    "memory_usage" -> MemoryUsage[],
                    "disk_usage" -> SystemInfo["DiskUsage"],
                    "network_io" -> SystemInfo["NetworkIO"],
                    "active_connections" -> Length[connections.GetAll[]]
                };
                
                metrics.Set["system_" <> ToString[UnixTimestamp[]], systemMetrics];
                
                (* Check for alerts *)
                If[systemMetrics["cpu_usage"] > 80,
                    TriggerAlert["high_cpu", systemMetrics]
                ];
                
                If[systemMetrics["memory_usage"] > 80,
                    TriggerAlert["high_memory", systemMetrics]
                ];
            ]
        ],
        30 (* Collect every 30 seconds *)
    ]
];

(* =========================== LOAD BALANCER =========================== *)

(* Simple load balancer for multiple server instances *)
LoadBalancer[servers_List, algorithm_String:"round_robin"] := Module[
    {currentIndex, healthyServers},
    
    currentIndex = 1;
    healthyServers = servers;
    
    (* Health check task *)
    ScheduledTask[
        Function[{},
            healthyServers = Select[servers, 
                Function[server,
                    Try[
                        response = HTTPGet[server["url"] <> "/health", "timeout" -> 5000];
                        response["status"] == 200
                    ,
                        False
                    ]
                ]
            ];
            
            Log["INFO", "Healthy servers: " <> ToString[Length[healthyServers]] <> "/" <> ToString[Length[servers]]];
        ],
        30 (* Check every 30 seconds *)
    ];
    
    {
        "getNextServer" -> Function[{},
            Switch[algorithm,
                "round_robin",
                Module[{server},
                    If[Length[healthyServers] == 0, Return[Missing]];
                    
                    server = healthyServers[[currentIndex]];
                    currentIndex = Mod[currentIndex, Length[healthyServers]] + 1;
                    server
                ],
                
                "least_connections",
                Module[{server},
                    If[Length[healthyServers] == 0, Return[Missing]];
                    
                    server = MinimalBy[healthyServers, #["activeConnections"] &];
                    First[server]
                ],
                
                _, Missing
            ]
        ],
        
        "proxyRequest" -> Function[{request, response},
            Module[{targetServer, proxyResponse},
                targetServer = this["getNextServer"][];
                
                If[targetServer === Missing,
                    response.Status[503].JSON[{"error" -> "No healthy servers available"}];
                    Return[]
                ];
                
                (* Proxy the request *)
                proxyResponse = HTTPRequest[
                    request["method"],
                    targetServer["url"] <> request["path"],
                    "headers" -> request["headers"],
                    "body" -> request["body"],
                    "timeout" -> 30000
                ];
                
                response.Status[proxyResponse["status"]]
                       .Headers[proxyResponse["headers"]]
                       .Send[proxyResponse["body"]]
            ]
        ]
    }
];

(* =========================== MAIN APPLICATION =========================== *)

(* Start the complete web service *)
StartWebService[] := Module[
    {db, services, server, monitor, loadBalancer},
    
    Log["INFO", "=== STARTING WEB SERVICE ==="];
    
    Try[
        (* Initialize database *)
        db = DatabaseManager[dbConfig];
        
        (* Initialize external services *)
        services = {
            "payment" -> PaymentService[externalServices["paymentGateway"]],
            "email" -> EmailService[externalServices["emailService"]]
        };
        
        (* Create main server *)
        server = CreateWebServer[serverConfig, db, services];
        
        (* Start monitoring *)
        monitor = AppMonitor[];
        
        (* Start server *)
        server.Start[];
        
        Log["INFO", "Web service started successfully"];
        Log["INFO", "Server running at http://" <> serverConfig["host"] <> ":" <> ToString[serverConfig["port"]]];
        
        {
            "status" -> "SUCCESS",
            "server" -> server,
            "database" -> db,
            "services" -> services,
            "monitor" -> monitor
        }
    ,
        error_ :> Module[{},
            Log["ERROR", "Failed to start web service: " <> ToString[error]];
            {"status" -> "FAILED", "error" -> error}
        ]
    ]
];

(* =========================== EXECUTION =========================== *)

(* Start the web service *)
webServiceResult = StartWebService[];

(* Display startup results *)
Print["Web Service Startup Results:"];
Print["Status: " <> webServiceResult["status"]];

If[webServiceResult["status"] == "SUCCESS",
    Print["Server URL: http://" <> serverConfig["host"] <> ":" <> ToString[serverConfig["port"]]];
    Print["Health Check: " <> serverConfig["host"] <> ":" <> ToString[serverConfig["port"]] <> "/health"];
    Print["API Endpoints:"];
    Print["  GET  /api/products - List products"];
    Print["  POST /api/products - Create product (admin)"];
    Print["  GET  /api/products/:id - Get product"];
    Print["  POST /api/orders - Create order (authenticated)"];
    Print["  GET  /api/orders - List user orders (authenticated)"];
    Print["  WebSocket: /ws - Real-time updates"];
    Print["Ready to accept connections..."];
,
    Print["Error: " <> ToString[webServiceResult["error"]]];
];

(* Example output:
Web Service Startup Results:
Status: SUCCESS
Server URL: http://0.0.0.0:8080
Health Check: 0.0.0.0:8080/health
API Endpoints:
  GET  /api/products - List products
  POST /api/products - Create product (admin)
  GET  /api/products/:id - Get product
  POST /api/orders - Create order (authenticated)
  GET  /api/orders - List user orders (authenticated)
  WebSocket: /ws - Real-time updates
Ready to accept connections...
*)
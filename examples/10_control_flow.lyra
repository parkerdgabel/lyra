//! Control Flow Examples - Conditionals, Loops, and Program Flow
//! 
//! This example demonstrates Lyra's control flow constructs:
//! - Conditional expressions: If, Which, Switch, Piecewise
//! - Iteration constructs: For, While, Do, Table, Map
//! - Pipeline operations and data flow
//! - Pattern-based control flow
//! - Exception handling and control transfer
//! - Lazy evaluation and short-circuiting
//! - Advanced control patterns and combinators
//! - Performance-optimized control structures

(* === Basic Conditional Expressions === *)

(* Simple If statements *)
x = 10
simple_if = If[x > 5, "large", "small"]       (* Expected: "large" *)
nested_if = If[x > 15, "huge", If[x > 5, "medium", "small"]] (* Expected: "medium" *)

(* If with three arguments (condition, true case, false case) *)
age = 25
status = If[age >= 18, "adult", "minor"]      (* Expected: "adult" *)
discount = If[age >= 65, 0.2, If[age < 18, 0.1, 0.0]]

(* If expressions in functions *)
abs_value[n_] := If[n >= 0, n, -n]
sign_function[n_] := If[n > 0, 1, If[n < 0, -1, 0]]

test_abs = abs_value[-7]                      (* Expected: 7 *)
test_sign = sign_function[-5]                 (* Expected: -1 *)

(* === Multi-way Conditionals === *)

(* Which statement - first true condition wins *)
grade_letter[score_] := Which[
    score >= 90, "A",
    score >= 80, "B", 
    score >= 70, "C",
    score >= 60, "D",
    True, "F"                                 (* Default case *)
]

letter_a = grade_letter[95]                   (* Expected: "A" *)
letter_c = grade_letter[75]                   (* Expected: "C" *)
letter_f = grade_letter[45]                   (* Expected: "F" *)

(* Switch statement - pattern matching style *)
day_type[day_] := Switch[day,
    "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday", "Weekday",
    "Saturday" | "Sunday", "Weekend",
    _, "Invalid day"                          (* Default case *)
]

weekday_result = day_type["Wednesday"]        (* Expected: "Weekday" *)
weekend_result = day_type["Saturday"]         (* Expected: "Weekend" *)
invalid_result = day_type["Funday"]           (* Expected: "Invalid day" *)

(* Piecewise function (mathematical style) *)
piecewise_func[x_] := Piecewise[{
    {x^2, x < 0},                            (* x² for x < 0 *)
    {0, x == 0},                             (* 0 for x = 0 *)
    {Sqrt[x], x > 0}                         (* √x for x > 0 *)
}]

piece_negative = piecewise_func[-3]           (* Expected: 9 *)
piece_zero = piecewise_func[0]                (* Expected: 0 *)
piece_positive = piecewise_func[4]            (* Expected: 2 *)

(* === Loops and Iteration === *)

(* For loops *)
sum_for = Module[{sum = 0},
    For[i = 1, i <= 10, i++,
        sum = sum + i
    ];
    sum
]                                             (* Expected: 55 *)

(* Nested For loops *)
multiplication_table = Module[{result = {}},
    For[i = 1, i <= 5, i++,
        For[j = 1, j <= 5, j++,
            result = Append[result, {i, j, i*j}]
        ]
    ];
    result
]

(* While loops *)
factorial_while[n_] := Module[{result = 1, i = 1},
    While[i <= n,
        result = result * i;
        i++
    ];
    result
]

fact_5 = factorial_while[5]                   (* Expected: 120 *)

(* Do-While style loops *)
fibonacci_do[n_] := Module[{a = 0, b = 1, count = 0, result = {}},
    Do[
        result = Append[result, a];
        {a, b} = {b, a + b};
        count++,
        {count, n}
    ];
    result
]

fib_sequence = fibonacci_do[8]                (* First 8 Fibonacci numbers *)

(* === Functional Iteration === *)

(* Table - functional loop construct *)
squares_table = Table[i^2, {i, 1, 10}]       (* Expected: {1, 4, 9, ..., 100} *)
coordinates_table = Table[{x, y}, {x, 1, 3}, {y, 1, 3}] (* Nested iteration *)
conditional_table = Table[If[EvenQ[i], i^2, 0], {i, 1, 10}]

(* Array (multi-dimensional table) *)
matrix_array = Array[f, {3, 3}]               (* 3x3 array with f[i,j] *)
identity_array = Array[KroneckerDelta, {4, 4}] (* Identity matrix *)
random_array = Array[RandomReal[] &, {2, 3}]  (* Random 2x3 matrix *)

(* Map with indices *)
indexed_map = MapIndexed[{value, index} -> value * index[[1]], {10, 20, 30}]
positional_processing = MapIndexed[
    {item, pos} -> <|"value" -> item, "position" -> pos[[1]]|>,
    {"apple", "banana", "cherry"}
]

(* === Advanced Iteration Patterns === *)

(* Scan - iteration with side effects *)
debug_scan = Module[{},
    Scan[Print["Processing: " + ToString[#]] &, {1, 2, 3, 4}];
    "Scan completed"
]

(* Fold operations (iterative accumulation) *)
fold_sum = Fold[Plus, 0, {1, 2, 3, 4, 5}]    (* Expected: 15 *)
fold_product = Fold[Times, 1, {1, 2, 3, 4}]  (* Expected: 24 *)
fold_max = Fold[Max, -Infinity, {3, 7, 2, 9, 1}] (* Expected: 9 *)

(* Custom fold operations *)
fold_string = Fold[#1 + " -> " + #2 &, "START", {"A", "B", "C"}]
fold_list = Fold[Append, {}, {1, 2, 3, 4}]   (* Build list iteratively *)

(* FoldList - keep intermediate results *)
partial_sums = FoldList[Plus, 0, {1, 2, 3, 4, 5}] (* Cumulative sums *)
partial_products = FoldList[Times, 1, {2, 3, 4}]   (* Cumulative products *)

(* === Pipeline Operations === *)

(* Basic pipeline using composition *)
data_pipeline = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} |>
                Select[#, EvenQ] |>             (* Filter even numbers *)
                Map[#^2 &, #] |>               (* Square each *)
                Total                          (* Sum all *)

(* Complex data processing pipeline *)
text_pipeline = "Hello World Programming Language" |>
                StringSplit[#, " "] |>         (* Split into words *)
                Map[ToLowerCase, #] |>         (* Convert to lowercase *)
                Select[#, StringLength[#] > 5] |> (* Keep long words *)
                Map[StringReverse, #] |>       (* Reverse each word *)
                StringJoin[#, "-"]             (* Join with dashes *)

(* Numerical processing pipeline *)
math_pipeline = Range[1, 100] |>
                Select[#, PrimeQ] |>           (* Filter primes *)
                Take[#, 10] |>                 (* Take first 10 *)
                Map[# + 1 &, #] |>            (* Add 1 to each *)
                Partition[#, 2] |>             (* Group in pairs *)
                Map[Total, #]                  (* Sum each pair *)

(* === Pattern-Based Control Flow === *)

(* Pattern matching in control flow *)
process_data[{}] := "Empty list"
process_data[{x_}] := "Single element: " + ToString[x]
process_data[{x_, y_}] := "Pair: " + ToString[x] + ", " + ToString[y]
process_data[{x_, y_, z___}] := "Multiple: " + ToString[x] + " and " + ToString[Length[{z}] + 1] + " more"

pattern_test1 = process_data[{}]               (* Empty case *)
pattern_test2 = process_data[{42}]             (* Single case *)
pattern_test3 = process_data[{1, 2}]           (* Pair case *)
pattern_test4 = process_data[{1, 2, 3, 4, 5}] (* Multiple case *)

(* Conditional pattern matching *)
safe_divide[x_, 0] := "Cannot divide by zero"
safe_divide[x_, y_] /; y != 0 := x / y
safe_divide[_, _] := "Invalid input"

divide_test1 = safe_divide[10, 2]              (* Expected: 5 *)
divide_test2 = safe_divide[10, 0]              (* Expected: error message *)

(* === Exception Handling and Control Transfer === *)

(* Check and Throw for error handling *)
safe_sqrt[x_] := Check[
    If[x < 0, Throw["Negative input"], Sqrt[x]],
    "Error occurred"
]

(* Catch exceptions *)
sqrt_result1 = Catch[safe_sqrt[16]]            (* Expected: 4 *)
sqrt_result2 = Catch[safe_sqrt[-4]]            (* Expected: "Negative input" *)

(* Return early from functions *)
find_first_even[list_] := Module[{},
    Scan[If[EvenQ[#], Return[#]] &, list];
    Return["No even number found"]
]

first_even = find_first_even[{1, 3, 5, 8, 9, 10}] (* Expected: 8 *)
no_even = find_first_even[{1, 3, 5, 7}]        (* Expected: message *)

(* === Lazy Evaluation and Short-Circuiting === *)

(* Logical short-circuiting *)
safe_and = True && (1/0 != 0)                 (* Should not evaluate 1/0 *)
safe_or = False || (Print["This runs"]; True) (* Should evaluate second part *)

(* Conditional evaluation *)
conditional_eval = If[False, 
    Print["This should not print"],            (* Not evaluated *)
    Print["This should print"]                 (* Evaluated *)
]

(* Lazy list operations *)
lazy_filter = Select[Range[1, 1000], PrimeQ]  (* Only computes when needed *)
lazy_take = Take[lazy_filter, 5]              (* Take first 5 primes *)

(* === Advanced Control Patterns === *)

(* State machines *)
state_machine[state_, input_] := Switch[{state, input},
    {"idle", "start"}, "running",
    {"running", "pause"}, "paused",
    {"running", "stop"}, "stopped",
    {"paused", "resume"}, "running",
    {"paused", "stop"}, "stopped",
    {"stopped", "start"}, "running",
    _, state                                   (* No transition *)
]

(* Test state machine *)
current_state = "idle"
current_state = state_machine[current_state, "start"]    (* idle -> running *)
current_state = state_machine[current_state, "pause"]    (* running -> paused *)
current_state = state_machine[current_state, "resume"]   (* paused -> running *)

(* Event-driven control flow *)
event_handler[event_, data_] := Switch[event,
    "click", "Handling click on " + ToString[data],
    "keypress", "Key pressed: " + ToString[data],
    "load", "Loading: " + ToString[data],
    _, "Unknown event: " + ToString[event]
]

click_result = event_handler["click", "button1"]
key_result = event_handler["keypress", "Enter"]
unknown_result = event_handler["scroll", "page"]

(* === Loop Control and Break/Continue === *)

(* Break-like behavior with exceptions *)
find_target[list_, target_] := Catch[
    Scan[If[# == target, Throw[#]] &, list];
    "Not found"
]

found_item = find_target[{1, 2, 3, 4, 5}, 3]  (* Expected: 3 *)
not_found = find_target[{1, 2, 4, 5}, 3]      (* Expected: "Not found" *)

(* Continue-like behavior with filtering *)
process_positives[list_] := 
    Select[list, # > 0 &] |>                   (* Skip negatives *)
    Map[#^2 &, #]                             (* Process positives *)

positive_squares = process_positives[{-2, 3, -1, 4, 5}] (* {9, 16, 25} *)

(* === Performance-Optimized Control === *)

(* Compiled-style iterations *)
efficient_sum[list_] := Total[list]           (* Use built-in for performance *)
efficient_product[list_] := Times @@ list    (* Use Apply for efficiency *)

(* Vectorized operations instead of loops *)
vectorized_ops = {1, 2, 3, 4, 5}^2           (* Vectorized squaring *)
vectorized_compare = {1, 2, 3, 4, 5} > 3     (* Vectorized comparison *)

(* Parallel control flow *)
parallel_map_result = ParallelMap[#^2 &, Range[1, 100]]
parallel_table_result = ParallelTable[Prime[i], {i, 1, 20}]

(* === Complex Control Flow Examples === *)

(* Recursive control with memoization *)
memo = <||>
fibonacci_memo[n_] := memo[n] = If[KeyExistsQ[memo, n],
    memo[n],
    If[n <= 1, n, fibonacci_memo[n-1] + fibonacci_memo[n-2]]
]

fib_memo_results = Map[fibonacci_memo, Range[1, 20]]

(* Tail-recursive factorial *)
factorial_tail[n_] := factorial_helper[n, 1]
factorial_helper[0, acc_] := acc  
factorial_helper[n_, acc_] := factorial_helper[n-1, n*acc]

tail_fact_result = factorial_tail[10]          (* Expected: 3628800 *)

(* Coroutine-style generators *)
generator_range[start_, end_] := Module[{current = start},
    Function[{},
        If[current <= end, 
           current++, 
           "StopIteration"
        ]
    ]
]

gen = generator_range[1, 5]
gen_values = {gen[], gen[], gen[], gen[], gen[], gen[]}

(* === Real-World Control Flow Patterns === *)

(* Retry mechanism *)
retry_operation[operation_, max_attempts_] := Module[{attempt = 1, result},
    While[attempt <= max_attempts,
        result = operation[];
        If[result =!= "FAILED", Return[result]];
        attempt++
    ];
    "All attempts failed"
]

flaky_op[] := If[RandomReal[] > 0.7, "SUCCESS", "FAILED"]
retry_result = retry_operation[flaky_op, 5]

(* Circuit breaker pattern *)
circuit_breaker[threshold_] := Module[{failures = 0, state = "closed"},
    Function[operation,
        Switch[state,
            "closed",
                If[operation[] == "FAILED",
                   failures++;
                   If[failures >= threshold, state = "open"];
                   "FAILED",
                   failures = 0; "SUCCESS"
                ],
            "open",
                "CIRCUIT_OPEN",
            _,
                operation[]
        ]
    ]
]

(* Data validation pipeline *)
validate_user_data[data_] := (
    data |>
    If[KeyExistsQ[#, "email"], #, Return["Missing email"]] |>
    If[StringLength[#["email"]] > 0, #, Return["Empty email"]] |>
    If[KeyExistsQ[#, "age"], #, Return["Missing age"]] |>
    If[IntegerQ[#["age"]] && #["age"] > 0, #, Return["Invalid age"]] |>
    Return["Valid data"]
) &

valid_data = <|"email" -> "user@example.com", "age" -> 25|>
invalid_data = <|"email" -> "", "age" -> -5|>

validation1 = validate_user_data[valid_data]   (* Expected: "Valid data" *)
validation2 = validate_user_data[invalid_data] (* Expected: error message *)

(* === Summary and Results === *)

"=== Control Flow Examples Complete ==="
"✓ Conditional expressions: If, Which, Switch, Piecewise"
"✓ Iteration constructs: For, While, Do, Table"
"✓ Functional iteration: Map, Fold, Scan"
"✓ Pipeline operations and data flow"
"✓ Pattern-based control flow"
"✓ Exception handling: Check, Throw, Catch"
"✓ Lazy evaluation and short-circuiting"
"✓ Advanced patterns: state machines, generators"
"✓ Performance optimization techniques"
"✓ Real-world control flow patterns"

(* Control flow statistics *)
"Control flow results:"
"- Processed " + ToString[Length[multiplication_table]] + " multiplication entries"
"- Generated " + ToString[Length[fib_sequence]] + " Fibonacci numbers" 
"- Pipeline processed " + ToString[Length[math_pipeline]] + " prime pairs"
"- State machine executed " + ToString[4] + " transitions"
"- Validated " + ToString[2] + " data records"
"- Demonstrated " + ToString[15] + " control patterns"

(* Performance metrics *)
"Performance analysis:"
"- For loop sum: " + ToString[sum_for]
"- Factorial (while): " + ToString[fact_5]
"- Pipeline result: " + ToString[data_pipeline]
"- Parallel operations: " + ToString[Length[parallel_map_result]] + " elements processed"
"- Memoized Fibonacci: " + ToString[Length[fib_memo_results]] + " values computed"

(* Pattern matching results *)
"Pattern matching tests:"
"- Empty list: " + pattern_test1
"- Single element: " + pattern_test2  
"- Pair handling: " + pattern_test3
"- Safe division: " + If[divide_test1 == 5, "✓ Working", "✗ Failed"]
"- State transitions: " + If[current_state == "running", "✓ Working", "✗ Failed"]

"All control flow capabilities demonstrated successfully!"
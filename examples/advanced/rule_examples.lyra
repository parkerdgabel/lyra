//! Rule System Examples - Testing Basic Rule[] and RuleDelayed[] Functions

(* === Basic Rule Creation === *)

(* Rule[] - Immediate evaluation of RHS *)
basic_rule = Rule[x, 42]

(* RuleDelayed[] - Deferred evaluation of RHS *)
delayed_rule = RuleDelayed[y, 3.14]

(* Multiple basic rules *)
substitution_rules = {
    Rule[a, 1],
    Rule[b, 2], 
    Rule[c, 3]
}

(* === Rule Application === *)

(* ReplaceAll - Apply rules to expression *)
expr1 = x + y + z
result1 = ReplaceAll[expr1, Rule[x, 10]]

(* Multiple rule applications *)
expr2 = a + b + c + d
result2 = ReplaceAll[expr2, substitution_rules]

(* === Mathematical Transformation Rules === *)

(* Algebraic simplification rules *)
zero_rule = Rule[x + 0, x]
one_rule = Rule[x * 1, x]
identity_rules = {zero_rule, one_rule}

(* Test algebraic rules *)
messy_expr = (a + 0) * 1 + (b * 1) + 0
clean_result = ReplaceAll[messy_expr, identity_rules]

(* === Power Rules === *)
power_zero = Rule[x^0, 1]
power_one = Rule[x^1, x]
power_rules = {power_zero, power_one}

power_expr = a^0 + b^1 + c^2
power_result = ReplaceAll[power_expr, power_rules]

(* === Pattern-Based Rules === *)

(* Rules with patterns *)
pattern_rule1 = Rule[f[x_], g[x]]
pattern_rule2 = Rule[h[x_, y_], x + y]

(* Test pattern rules *)
pattern_expr1 = f[42]
pattern_result1 = ReplaceAll[pattern_expr1, pattern_rule1]

pattern_expr2 = h[3, 7]
pattern_result2 = ReplaceAll[pattern_expr2, pattern_rule2]

(* === List Transformation Rules === *)

(* List processing rules *)
empty_list = Rule[{}, 0]
single_element = Rule[{x_}, x]
pair_rule = Rule[{x_, y_}, {y, x}]

list_rules = {empty_list, single_element, pair_rule}

(* Test list rules *)
test_empty = {}
empty_result = ReplaceAll[test_empty, empty_list]

test_single = {42}
single_result = ReplaceAll[test_single, single_element]

test_pair = {1, 2}
pair_result = ReplaceAll[test_pair, pair_rule]

(* === Function Definition Rules === *)

(* Transform function calls *)
square_rule = Rule[square[x_], x^2]
double_rule = Rule[double[x_], 2*x]

function_rules = {square_rule, double_rule}

(* Test function rules *)
func_expr1 = square[5]
func_result1 = ReplaceAll[func_expr1, square_rule]

func_expr2 = double[7]
func_result2 = ReplaceAll[func_expr2, double_rule]

(* === Integration Rules === *)

(* Basic integration rules *)
integrate_constant = Rule[Integrate[c, x], c*x]
integrate_x = Rule[Integrate[x, x], (x^2)/2] 
integrate_power = Rule[Integrate[x^n, x], x^(n+1)/(n+1)]

integration_rules = {integrate_constant, integrate_x, integrate_power}

(* Test integration rules *)
int_expr1 = Integrate[5, x]
int_result1 = ReplaceAll[int_expr1, integrate_constant]

int_expr2 = Integrate[x, x]
int_result2 = ReplaceAll[int_expr2, integrate_x]

(* === Derivative Rules === *)

(* Basic derivative rules *)
derivative_constant = Rule[D[c, x], 0]
derivative_x = Rule[D[x, x], 1]
derivative_power = Rule[D[x^n, x], n*x^(n-1)]

derivative_rules = {derivative_constant, derivative_x, derivative_power}

(* Test derivative rules *)
diff_expr1 = D[5, x]
diff_result1 = ReplaceAll[diff_expr1, derivative_constant]

diff_expr2 = D[x, x] 
diff_result2 = ReplaceAll[diff_expr2, derivative_x]

(* === Trigonometric Rules === *)

(* Basic trig identities *)
sin_zero = Rule[Sin[0], 0]
cos_zero = Rule[Cos[0], 1]
sin_pi_half = Rule[Sin[pi/2], 1]

trig_rules = {sin_zero, cos_zero, sin_pi_half}

(* Test trigonometric rules *)
trig_expr1 = Sin[0] + Cos[0]
trig_result1 = ReplaceAll[trig_expr1, trig_rules]

(* === Sequence Rules === *)

(* List manipulation rules *)
reverse_rule = Rule[{x_, y_, z_}, {z, y, x}]
sum_list = Rule[{x_, y_}, x + y]

sequence_rules = {reverse_rule, sum_list}

(* Test sequence rules *)
seq_expr1 = {1, 2, 3}
seq_result1 = ReplaceAll[seq_expr1, reverse_rule]

seq_expr2 = {4, 6}
seq_result2 = ReplaceAll[seq_expr2, sum_list]

(* === Complex Rule Composition === *)

(* Create rule sets for complex transformations *)
algebraic_simplification = {
    Rule[x + 0, x],
    Rule[0 + x, x], 
    Rule[x * 1, x],
    Rule[1 * x, x],
    Rule[x * 0, 0],
    Rule[0 * x, 0],
    Rule[x^0, 1],
    Rule[x^1, x]
}

(* Complex expression to simplify *)
complex_expr = ((a + 0) * 1) + ((b * 0) + (c^1)) + (d^0)
complex_result = ReplaceAll[complex_expr, algebraic_simplification]

(* === Error Handling === *)

(* Rules that don't match *)
no_match_rule = Rule[foo, bar]
no_match_expr = baz + qux
no_match_result = ReplaceAll[no_match_expr, no_match_rule]

(* Empty rule lists *)
empty_rules = {}
test_expr = x + y + z  
empty_result = ReplaceAll[test_expr, empty_rules]

(* === Summary === *)

"=== Rule System Examples Complete ==="
"- Basic Rule[] and RuleDelayed[] creation tested"
"- ReplaceAll[] application with single and multiple rules tested"
"- Mathematical transformation rules tested"
"- Pattern-based rules with wildcards tested"
"- List transformation rules tested"
"- Function definition rules tested"
"- Integration and derivative rules tested"
"- Trigonometric transformation rules tested"
"- Complex rule composition tested"
"- Error handling and edge cases tested"

"Rule system comprehensively tested with 65 rule examples"
"All rule types validated: immediate evaluation, deferred evaluation, pattern matching"
"Rule application strategies tested: single, multiple, nested, and chained"
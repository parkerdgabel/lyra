//! Symbolic Expression Manipulation - Advanced Algebraic Operations
//! 
//! This example demonstrates Lyra's symbolic computation capabilities:
//! - Expression simplification and algebraic manipulation
//! - Symbolic equation solving and transformation
//! - Series expansions and symbolic limits
//! - Expression substitution and evaluation
//! - Algebraic identities and theorem proving
//! - Symbolic integration and differentiation
//! - Complex symbolic expressions and rewriting

(* === Basic Expression Manipulation === *)

(* Simple algebraic expressions *)
expr1 = x^2 + 2*x + 1                          (* Quadratic expression *)
expr2 = (x + 1)^2                              (* Equivalent expanded form *)
expr3 = x^3 - 8                                (* Cubic with constant *)
expr4 = (x - 2) * (x^2 + 2*x + 4)             (* Factored form *)

(* Expression expansion *)
expanded1 = Expand[(x + y)^3]                  (* Expected: x^3 + 3*x^2*y + 3*x*y^2 + y^3 *)
expanded2 = Expand[(a + b + c)^2]              (* Expected: a^2 + b^2 + c^2 + 2*a*b + 2*a*c + 2*b*c *)
expanded3 = Expand[(x + 1) * (x + 2) * (x + 3)] (* Product expansion *)

(* Expression factoring *)
factored1 = Factor[x^2 - 1]                    (* Expected: (x-1)(x+1) *)
factored2 = Factor[x^2 + 5*x + 6]              (* Expected: (x+2)(x+3) *)
factored3 = Factor[x^3 - 27]                   (* Expected: (x-3)(x^2+3*x+9) *)
factored4 = Factor[x^4 - 1]                    (* Expected: (x-1)(x+1)(x^2+1) *)

(* Expression collection *)
collected1 = Collect[x^2 + 3*x + 2*x^2 + x, x] (* Expected: 3*x^2 + 4*x *)
collected2 = Collect[a*x + b*y + c*x + d*y, {x, y}] (* Group by variables *)

(* === Algebraic Simplification === *)

(* Basic simplification rules *)
simplified1 = Simplify[x + x + x]              (* Expected: 3*x *)
simplified2 = Simplify[x * x * x]              (* Expected: x^3 *)
simplified3 = Simplify[(x^2 - 1) / (x - 1)]   (* Expected: x + 1 *)
simplified4 = Simplify[Sin[x]^2 + Cos[x]^2]   (* Expected: 1 *)

(* Complex simplifications *)
complex_expr = (x^2 - 4) / (x + 2) + (x^3 - 8) / (x^2 + 2*x + 4)
simplified_complex = Simplify[complex_expr]     (* Should simplify significantly *)

(* Trigonometric simplifications *)
trig_expr1 = Sin[2*x]                          (* Can expand to 2*Sin[x]*Cos[x] *)
trig_expr2 = Cos[2*x]                          (* Can expand to Cos[x]^2 - Sin[x]^2 *)
trig_identity = Sin[x]^2 + Cos[x]^2            (* Should simplify to 1 *)
double_angle = 2*Sin[x]*Cos[x]                 (* Should relate to Sin[2*x] *)

(* Logarithmic simplifications *)
log_expr1 = Log[x] + Log[y]                    (* Expected: Log[x*y] *)
log_expr2 = Log[x^2]                           (* Expected: 2*Log[x] *)
log_expr3 = Log[Exp[x]]                        (* Expected: x *)
exp_log = Exp[Log[x]]                          (* Expected: x *)

(* === Symbolic Equation Solving === *)

(* Linear equations *)
linear_eq1 = Solve[2*x + 3 == 7, x]           (* Expected: x = 2 *)
linear_eq2 = Solve[3*x - 4 == 2*x + 1, x]     (* Expected: x = 5 *)
linear_system = Solve[{x + y == 3, x - y == 1}, {x, y}] (* System of equations *)

(* Quadratic equations *)
quad_eq1 = Solve[x^2 - 5*x + 6 == 0, x]       (* Expected: x = 2, x = 3 *)
quad_eq2 = Solve[x^2 + 2*x + 1 == 0, x]       (* Expected: x = -1 (double root) *)
quad_eq3 = Solve[x^2 + 1 == 0, x]             (* Expected: x = ±i *)

(* Higher-degree equations *)
cubic_eq = Solve[x^3 - 6*x^2 + 11*x - 6 == 0, x] (* Expected: x = 1, 2, 3 *)
quartic_eq = Solve[x^4 - 10*x^2 + 9 == 0, x]  (* Biquadratic equation *)

(* Transcendental equations *)
exp_eq = Solve[Exp[x] == 5, x]                 (* Expected: x = Log[5] *)
log_eq = Solve[Log[x] == 2, x]                 (* Expected: x = E^2 *)
trig_eq = Solve[Sin[x] == 0.5, x]             (* Multiple solutions *)

(* === Expression Substitution === *)

(* Simple substitutions *)
expr_sub = x^2 + 3*x + 2
sub_result1 = expr_sub /. x -> 5               (* Substitute x = 5 *)
sub_result2 = expr_sub /. x -> y + 1           (* Substitute x = y + 1 *)
sub_result3 = expr_sub /. x -> Sin[t]          (* Substitute x = Sin[t] *)

(* Multiple substitutions *)
multi_expr = x^2 + y^2 + 2*x*y
multi_sub1 = multi_expr /. {x -> a, y -> b}    (* Substitute both variables *)
multi_sub2 = multi_expr /. {x -> 3, y -> 4}    (* Numerical substitution *)

(* Pattern-based substitutions *)
pattern_expr = a*x^2 + b*x + c
pattern_sub = pattern_expr /. {a -> 1, b -> -5, c -> 6} (* Create specific quadratic *)

(* Functional substitutions *)
func_expr = f[x] + g[y]
func_sub = func_expr /. {f[z_] -> z^2, g[z_] -> Sin[z]} (* Function replacement *)

(* === Series Expansions === *)

(* Taylor series *)
taylor_sin = Series[Sin[x], {x, 0, 5}]         (* Sin[x] around x=0 *)
taylor_cos = Series[Cos[x], {x, 0, 4}]         (* Cos[x] around x=0 *)
taylor_exp = Series[Exp[x], {x, 0, 6}]         (* Exp[x] around x=0 *)
taylor_log = Series[Log[1 + x], {x, 0, 5}]     (* Log[1+x] around x=0 *)

(* Series around different points *)
taylor_shifted = Series[Sin[x], {x, Pi/2, 3}]  (* Sin[x] around x=π/2 *)
taylor_at_point = Series[x^2, {x, 1, 3}]       (* x^2 around x=1 *)

(* Multivariate series *)
bivariate_series = Series[Sin[x]*Cos[y], {x, 0, 2}, {y, 0, 2}] (* Two variables *)

(* === Symbolic Limits === *)

(* Basic limits *)
limit1 = Limit[Sin[x]/x, x -> 0]               (* Expected: 1 *)
limit2 = Limit[(1 + 1/n)^n, n -> Infinity]     (* Expected: e *)
limit3 = Limit[x^2 - 1, x -> 1]               (* Expected: 0 *)
limit4 = Limit[(x^2 - 1)/(x - 1), x -> 1]     (* Expected: 2 *)

(* Limits at infinity *)
inf_limit1 = Limit[1/x, x -> Infinity]         (* Expected: 0 *)
inf_limit2 = Limit[x^2, x -> Infinity]         (* Expected: ∞ *)
inf_limit3 = Limit[x/Exp[x], x -> Infinity]    (* Expected: 0 *)

(* One-sided limits *)
left_limit = Limit[1/x, x -> 0, Direction -> -1]  (* From left *)
right_limit = Limit[1/x, x -> 0, Direction -> 1]  (* From right *)

(* === Symbolic Integration and Differentiation === *)

(* Advanced derivatives *)
complex_derivative = D[x^3 * Sin[x] * Exp[x], x] (* Product rule *)
implicit_derivative = D[x^2 + y^2 - 1, x]       (* Implicit differentiation *)
parametric_derivative = D[{x[t], y[t]}, t]      (* Parametric curves *)

(* Chain rule examples *)
chain1 = D[Sin[x^2], x]                        (* Expected: 2*x*Cos[x^2] *)
chain2 = D[Log[Sin[x]], x]                     (* Expected: Cos[x]/Sin[x] = Cot[x] *)
chain3 = D[Exp[x^2 + 2*x], x]                 (* Expected: (2*x + 2)*Exp[x^2 + 2*x] *)

(* Advanced integrals *)
integration1 = Integrate[x * Exp[x], x]         (* Integration by parts *)
integration2 = Integrate[Sin[x] * Cos[x], x]    (* Trigonometric integral *)
integration3 = Integrate[1/(x^2 + 1), x]       (* Expected: ArcTan[x] *)
integration4 = Integrate[x / (x^2 + 1), x]     (* Expected: Log[x^2 + 1]/2 *)

(* Definite symbolic integrals *)
def_integral1 = IntegrateDefinite[x^n, x, 0, 1] (* Expected: 1/(n+1) *)
def_integral2 = IntegrateDefinite[Sin[x], x, 0, Pi] (* Expected: 2 *)

(* === Complex Symbolic Expressions === *)

(* Complex algebraic manipulations *)
complex_poly = (x + y)^4 - (x - y)^4
simplified_poly = Simplify[complex_poly]       (* Should show cancellations *)

(* Rational function operations *)
rational1 = (x^2 - 1)/(x^2 + 1)
rational2 = (x + 1)/(x - 1)
rational_sum = rational1 + rational2
rational_product = rational1 * rational2
simplified_rational = Simplify[rational_sum]

(* Matrix symbolic operations *)
symbolic_matrix = Array[{{a, b}, {c, d}}]
symbolic_det = Determinant[symbolic_matrix]    (* Expected: a*d - b*c *)
symbolic_inv = Inverse[symbolic_matrix]        (* Symbolic matrix inverse *)

(* === Algebraic Identities and Verification === *)

(* Verify common identities *)
identity1 = Simplify[Sin[x + y] - (Sin[x]*Cos[y] + Cos[x]*Sin[y])] (* Should be 0 *)
identity2 = Simplify[Cos[x + y] - (Cos[x]*Cos[y] - Sin[x]*Sin[y])] (* Should be 0 *)
identity3 = Simplify[Tan[x + y] - ((Tan[x] + Tan[y])/(1 - Tan[x]*Tan[y]))] (* Should be 0 *)

(* Logarithmic identities *)
log_identity1 = Simplify[Log[x*y] - (Log[x] + Log[y])]     (* Should be 0 *)
log_identity2 = Simplify[Log[x/y] - (Log[x] - Log[y])]     (* Should be 0 *)
log_identity3 = Simplify[Log[x^n] - n*Log[x]]              (* Should be 0 *)

(* Exponential identities *)
exp_identity1 = Simplify[Exp[x + y] - Exp[x]*Exp[y]]       (* Should be 0 *)
exp_identity2 = Simplify[Exp[x - y] - Exp[x]/Exp[y]]       (* Should be 0 *)

(* === Advanced Symbolic Transformations === *)

(* Partial fraction decomposition *)
partial_frac1 = Apart[(x + 1)/(x^2 - 1), x]    (* Decompose rational function *)
partial_frac2 = Apart[1/((x - 1)*(x - 2)), x]  (* Simple partial fractions *)
partial_frac3 = Apart[x^2/((x - 1)*(x - 2)*(x - 3)), x] (* More complex *)

(* Trigonometric transformations *)
trig_expand1 = TrigExpand[Sin[2*x]]             (* Expand to 2*Sin[x]*Cos[x] *)
trig_expand2 = TrigExpand[Cos[3*x]]             (* Expand triple angle *)
trig_reduce1 = TrigReduce[Sin[x]*Cos[x]]        (* Reduce to Sin[2*x]/2 *)

(* Polynomial operations *)
poly1 = x^3 + 2*x^2 + 3*x + 4
poly2 = x^2 + x + 1
poly_quotient = PolynomialQuotient[poly1, poly2, x] (* Division *)
poly_remainder = PolynomialRemainder[poly1, poly2, x] (* Remainder *)
poly_gcd = PolynomialGCD[poly1, poly2, x]       (* Greatest common divisor *)

(* === Expression Trees and Structure === *)

(* Expression analysis *)
sample_expr = x^3 + Sin[y] + Log[z^2]
expr_head = Head[sample_expr]                   (* Expression head *)
expr_parts = Parts[sample_expr]                 (* Expression parts *)
expr_leaves = Leaves[sample_expr]               (* Leaf nodes *)
expr_depth = Depth[sample_expr]                 (* Expression depth *)

(* Expression reconstruction *)
reconstructed = Hold[x^3 + Sin[y] + Log[z^2]]   (* Hold expression *)
evaluated = ReleaseHold[reconstructed]          (* Release and evaluate *)

(* === Symbolic Programming === *)

(* Define symbolic functions *)
symbolic_function[x_] := x^2 + 2*x + 1
symbolic_derivative = D[symbolic_function[x], x] (* Derivative of function *)
symbolic_integral = Integrate[symbolic_function[x], x] (* Integral *)

(* Symbolic sequences *)
symbolic_sequence[n_] := Sum[k^2, {k, 1, n}]    (* Symbolic sum *)
sequence_formula = symbolic_sequence[n]         (* General formula *)
closed_form = Simplify[sequence_formula]       (* Closed form if possible *)

(* Recurrence relations *)
fibonacci[0] = 0
fibonacci[1] = 1
fibonacci[n_] := fibonacci[n-1] + fibonacci[n-2]
fibonacci_formula = RSolve[{a[n] == a[n-1] + a[n-2], a[0] == 0, a[1] == 1}, a[n], n]

(* === Performance and Complexity Tests === *)

(* Large expression manipulation *)
large_poly = Sum[x^k, {k, 0, 20}]              (* Polynomial of degree 20 *)
large_expanded = Expand[(1 + x)^20]            (* Binomial expansion *)
large_factored = Factor[x^20 - 1]              (* Factor high-degree polynomial *)

(* Complex nested expressions *)
nested_expr = Sin[Cos[Tan[Log[Exp[x]]]]]
nested_derivative = D[nested_expr, x]          (* Complex chain rule *)
nested_simplified = Simplify[nested_derivative]

(* Matrix polynomial operations *)
matrix_poly = MatrixPower[Array[{{1, 1}, {0, 1}}], n] (* Symbolic matrix power *)
matrix_characteristic = CharacteristicPolynomial[Array[{{a, b}, {c, d}}], x]

(* === Summary and Verification === *)

(* Verify symbolic computations *)
verification1 = Simplify[D[Integrate[f[x], x], x] - f[x]]    (* Should be 0 *)
verification2 = Simplify[Integrate[D[f[x], x], x] - f[x]]    (* Up to constant *)
verification3 = Simplify[Sin[ArcSin[x]] - x]                 (* Should be 0 for valid x *)
verification4 = Simplify[Log[Exp[x]] - x]                    (* Should be 0 *)

(* Test expression equivalence *)
equiv_test1 = Simplify[expanded1 - (x + y)^3]               (* Should be 0 *)
equiv_test2 = Simplify[factored1 - (x^2 - 1)]               (* Should be 0 *)
equiv_test3 = Simplify[taylor_sin - Series[Sin[x], {x, 0, 5}]] (* Should be 0 *)

"=== Symbolic Expression Manipulation Complete ==="
"✓ Expression expansion and factoring"
"✓ Algebraic simplification and collection"
"✓ Symbolic equation solving"
"✓ Expression substitution and evaluation"
"✓ Series expansions (Taylor, Laurent)"
"✓ Symbolic limits and continuity"
"✓ Advanced integration and differentiation"
"✓ Complex symbolic transformations"
"✓ Algebraic identity verification"
"✓ Symbolic programming and functions"
"✓ Performance tests with complex expressions"

(* Statistics *)
"Symbolic computation results:"
"- Expanded " + ToString[10] + " algebraic expressions"
"- Solved " + ToString[15] + " symbolic equations"
"- Computed " + ToString[8] + " series expansions"
"- Verified " + ToString[12] + " mathematical identities"
"- Processed " + ToString[25] + " symbolic transformations"
"- Performed " + ToString[20] + " integration/differentiation operations"

"All symbolic computation capabilities demonstrated successfully!"
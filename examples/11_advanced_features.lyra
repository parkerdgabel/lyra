//! Advanced Features Examples - Modern Language Constructs
//! 
//! This example demonstrates Lyra's advanced modern language features:
//! - String interpolation and template strings
//! - Dot notation and method calls
//! - Arrow functions and lambda expressions
//! - Pipeline operators and data flow
//! - Modern syntax extensions
//! - Async/await patterns (if supported)
//! - Module system and imports
//! - Metaprogramming capabilities

(* === String Interpolation === *)

(* Basic string interpolation *)
name = "Alice"
age = 30
city = "New York"

interpolated_basic = f"Hello, my name is {name} and I am {age} years old."
interpolated_complex = f"I live in {city} and will be {age + 1} next year."

(* Expression interpolation *)
x = 10
y = 20
math_interpolation = f"The sum of {x} and {y} is {x + y}, and their product is {x * y}."

(* Function call interpolation *)
square[n_] := n^2
func_interpolation = f"The square of {x} is {square[x]}."

(* Conditional interpolation *)
score = 85
grade_interpolation = f"Your score is {score}, which is {If[score >= 90, 'excellent', If[score >= 80, 'good', 'needs improvement']]}."

(* Multi-line string interpolation *)
multi_line = f"""
User Information:
  Name: {name}
  Age: {age}
  Location: {city}
  Status: {If[age >= 18, "Adult", "Minor"]}
"""

(* === Advanced String Operations === *)

(* String templates with placeholders *)
template = StringTemplate["Hello {name}, you have {count} messages."]
template_result1 = template[<|"name" -> "Bob", "count" -> 5|>]
template_result2 = template[<|"name" -> "Carol", "count" -> 12|>]

(* Regular expression operations *)
email_pattern = RegularExpression["[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"]
phone_pattern = RegularExpression["\\d{3}-\\d{3}-\\d{4}"]

email_test = "user@example.com"
phone_test = "123-456-7890"
invalid_email = "not-an-email"

email_match = StringMatch[email_test, email_pattern]         (* Expected: True *)
phone_match = StringMatch[phone_test, phone_pattern]         (* Expected: True *)
invalid_match = StringMatch[invalid_email, email_pattern]    (* Expected: False *)

(* String extraction with regex *)
text_with_emails = "Contact us at info@company.com or support@help.org"
extracted_emails = StringExtract[text_with_emails, email_pattern]

(* String replacement with patterns *)
masked_text = StringReplace[text_with_emails, 
    email_pattern -> "***@***.***"]

(* === Dot Notation and Method Calls === *)

(* Simulated object with methods *)
Person[name_, age_] := <|
    "name" -> name,
    "age" -> age,
    "greet" -> Function[{}, f"Hello, I'm {name}"],
    "birthday" -> Function[{}, Person[name, age + 1]],
    "isAdult" -> Function[{}, age >= 18],
    "toString" -> Function[{}, f"Person({name}, {age})"]
|>

(* Create person instance *)
alice = Person["Alice", 25]

(* Method calls using dot notation (simulated) *)
alice_greeting = alice["greet"][]               (* Call greet method *)
alice_adult = alice["isAdult"][]                (* Call isAdult method *)
alice_string = alice["toString"][]              (* Call toString method *)
older_alice = alice["birthday"][]               (* Create new instance *)

(* Chaining method calls *)
chain_result = alice["birthday"][]["birthday"][]["toString"][] (* Chain calls *)

(* Collection methods with dot notation *)
NumberList[data_] := <|
    "data" -> data,
    "length" -> Function[{}, Length[data]],
    "sum" -> Function[{}, Total[data]],
    "mean" -> Function[{}, Mean[data]],
    "max" -> Function[{}, Max[data]],
    "min" -> Function[{}, Min[data]],
    "filter" -> Function[predicate, NumberList[Select[data, predicate]]],
    "map" -> Function[func, NumberList[Map[func, data]]],
    "sort" -> Function[{}, NumberList[Sort[data]]],
    "toString" -> Function[{}, ToString[data]]
|>

(* Test collection methods *)
numbers = NumberList[{5, 2, 8, 1, 9, 3}]
numbers_length = numbers["length"][]            (* Expected: 6 *)
numbers_sum = numbers["sum"][]                  (* Expected: 28 *)
numbers_mean = numbers["mean"][]                (* Expected: 4.67 *)

(* Method chaining *)
processed_numbers = numbers["filter"][# > 3 &]["map"][#^2 &]["sort"][]
final_result = processed_numbers["toString"][]

(* === Arrow Functions === *)

(* Basic arrow functions *)
add_arrow = {x, y} -> x + y                    (* Two parameter arrow *)
square_arrow = x -> x^2                        (* Single parameter *)
constant_arrow = {} -> 42                      (* No parameters *)

(* Test arrow functions *)
add_result = add_arrow[{5, 3}]                 (* Expected: 8 *)
square_result = square_arrow[7]                (* Expected: 49 *)
constant_result = constant_arrow[{}]           (* Expected: 42 *)

(* Arrow functions with complex bodies *)
factorial_arrow = n -> If[n <= 1, 1, n * factorial_arrow[n - 1]]
fibonacci_arrow = n -> If[n <= 1, n, fibonacci_arrow[n - 1] + fibonacci_arrow[n - 2]]

fact_arrow_test = factorial_arrow[5]           (* Expected: 120 *)
fib_arrow_test = fibonacci_arrow[8]            (* Expected: 21 *)

(* Arrow functions in higher-order functions *)
squared_odds = Select[Range[1, 20], OddQ] |>
               Map[x -> x^2, #] |>
               Select[#, x -> x > 10] (* Use arrow functions in pipeline *)

(* Curried arrow functions *)
curried_add = x -> y -> x + y
add_five = curried_add[5]
add_five_result = add_five[10]                 (* Expected: 15 *)

(* === Pipeline Operations === *)

(* Basic pipeline with |> *)
pipeline_result = Range[1, 100] |>
    Select[#, PrimeQ] |>                       (* Filter primes *)
    Take[#, 10] |>                             (* Take first 10 *)
    Map[#^2 &, #] |>                           (* Square each *)
    Total                                      (* Sum all *)

(* Data processing pipeline *)
text = "The Quick Brown Fox Jumps Over The Lazy Dog"
text_pipeline = text |>
    ToLowerCase |>                             (* Convert to lowercase *)
    StringSplit[#, " "] |>                     (* Split into words *)
    Map[StringReverse, #] |>                   (* Reverse each word *)
    Select[#, StringLength[#] > 3] |>          (* Keep longer words *)
    StringJoin[#, "-"]                         (* Join with dashes *)

(* Mathematical pipeline *)
math_result = 2 |>
    Power[#, 3] |>                             (* Cube it: 8 *)
    Sqrt |>                                    (* Square root: 2√2 *)
    Log |>                                     (* Natural log *)
    Exp                                        (* Exponential *)

(* Complex data transformation pipeline *)
student_data = {
    <|"name" -> "Alice", "scores" -> {85, 90, 78}|>,
    <|"name" -> "Bob", "scores" -> {92, 88, 95}|>,
    <|"name" -> "Carol", "scores" -> {76, 82, 88}|>
}

processed_students = student_data |>
    Map[student -> <|student, "average" -> Mean[student["scores"]]|>, #] |>
    Select[#, #["average"] >= 80] |>
    Map[#["name"] &, #] |>
    Sort

(* === Modern Syntax Extensions === *)

(* Range syntax with step *)
range_modern = 1..10                           (* Simple range *)
range_step = 0..20..2                          (* Range with step *)
range_real = 0.0..2.0..0.5                     (* Real range *)

(* List comprehensions (if supported) *)
list_comp = [x^2 | x <- Range[1, 10], x > 5]  (* Squares of numbers > 5 *)
nested_comp = [{x, y} | x <- Range[1, 3], y <- Range[1, 3], x != y]

(* Pattern destructuring *)
{first, second, rest___} = {1, 2, 3, 4, 5}
destructure_test = f"First: {first}, Second: {second}, Rest: {Length[{rest}]} items"

(* Association destructuring *)
person_info = <|"name" -> "David", "age" -> 35, "city" -> "Boston"|>
person_name = person_info["name"]
person_details = f"Name: {person_name}, Age: {person_info['age']}"

(* === Async/Await Patterns (Simulated) === *)

(* Simulate async operations *)
AsyncResult[value_] := <|"type" -> "async", "value" -> value, "completed" -> True|>
Pending[operation_] := <|"type" -> "pending", "operation" -> operation|>

(* Async function simulation *)
async_fetch[url_] := AsyncResult[f"Data from {url}"]
async_process[data_] := AsyncResult[f"Processed: {data}"]

(* Async chaining *)
fetch_result = async_fetch["https://api.example.com"]
process_result = async_process[fetch_result["value"]]

(* Promise-like patterns *)
Promise[executor_] := <|
    "then" -> Function[callback, Promise[{} -> callback[executor[]]]],
    "catch" -> Function[error_handler, Promise[executor]],  (* Simplified *)
    "value" -> Function[{}, executor[]]
|>

test_promise = Promise[{} -> "Hello, World!"]
promise_result = test_promise["value"][]

(* === Metaprogramming Capabilities === *)

(* Code generation *)
generate_accessor[field_] := Function[obj, obj[field]]
generate_setter[field_] := Function[{obj, value}, <|obj, field -> value|>]

name_getter = generate_accessor["name"]
age_setter = generate_setter["age"]

test_obj = <|"name" -> "Emma", "age" -> 28|>
gotten_name = name_getter[test_obj]            (* Expected: "Emma" *)
updated_obj = age_setter[test_obj, 29]

(* Dynamic function creation *)
create_polynomial[coeffs_] := Function[x, 
    Total[MapIndexed[{coeff, index} -> coeff * x^(index[[1]] - 1), coeffs]]
]

quadratic = create_polynomial[{1, -2, 1}]      (* x² - 2x + 1 *)
quad_result = quadratic[3]                     (* Expected: 4 *)

(* Expression manipulation *)
build_expression[op_, args___] := Apply[op, {args}]
dynamic_expr = build_expression[Plus, 1, 2, 3, 4] (* Plus[1,2,3,4] *)

(* === Module System Simulation === *)

(* Namespace simulation *)
MathUtils = <|
    "square" -> Function[x, x^2],
    "cube" -> Function[x, x^3],
    "factorial" -> Function[n, If[n <= 1, 1, n * MathUtils["factorial"][n-1]]],
    "fibonacci" -> Function[n, If[n <= 1, n, 
        MathUtils["fibonacci"][n-1] + MathUtils["fibonacci"][n-2]]]
|>

StringUtils = <|
    "reverse" -> Function[s, StringReverse[s]],
    "palindrome" -> Function[s, s == StringReverse[s]],
    "wordCount" -> Function[s, Length[StringSplit[s, " "]]],
    "capitalize" -> Function[s, StringJoin[ToUpperCase[StringTake[s, 1]], 
        ToLowerCase[StringDrop[s, 1]]]]
|>

(* Use namespace functions *)
math_square = MathUtils["square"][5]           (* Expected: 25 *)
math_factorial = MathUtils["factorial"][4]     (* Expected: 24 *)
string_reverse = StringUtils["reverse"]["hello"] (* Expected: "olleh" *)
is_palindrome = StringUtils["palindrome"]["racecar"] (* Expected: True *)

(* === Advanced Pattern Matching with Modern Syntax === *)

(* Modern pattern matching syntax *)
match_value[value_] := Switch[value,
    x_ /; IntegerQ[x] && x > 0, f"Positive integer: {x}",
    x_ /; IntegerQ[x] && x < 0, f"Negative integer: {x}",
    x_ /; IntegerQ[x] && x == 0, "Zero",
    x_ /; StringQ[x], f"String: '{x}'",
    x_List, f"List with {Length[x]} elements",
    _, "Unknown type"
]

match_tests = Map[match_value, {5, -3, 0, "hello", {1, 2, 3}, 3.14}]

(* Guard clauses *)
grade_with_guard[score_] := Which[
    score >= 97, "A+",
    score >= 93, "A", 
    score >= 90, "A-",
    score >= 87, "B+",
    score >= 83, "B",
    score >= 80, "B-",
    score >= 77, "C+",
    score >= 73, "C",
    score >= 70, "C-",
    score >= 67, "D+",
    score >= 63, "D",
    score >= 60, "D-",
    True, "F"
]

grade_results = Map[grade_with_guard, {98, 85, 72, 55}]

(* === Performance and Optimization === *)

(* Memoization with modern syntax *)
memoized_fib = Module[{cache = <||>},
    Function[n,
        If[KeyExistsQ[cache, n],
            cache[n],
            cache[n] = If[n <= 1, n, memoized_fib[n-1] + memoized_fib[n-2]]
        ]
    ]
]

memo_results = Map[memoized_fib, Range[1, 20]]

(* Lazy evaluation *)
lazy_sequence[start_, gen_] := Module[{current = start},
    Function[{},
        current = gen[current];
        current
    ]
]

geometric_sequence = lazy_sequence[1, #*2 &]
lazy_values = {geometric_sequence[], geometric_sequence[], 
               geometric_sequence[], geometric_sequence[]}

(* === Summary and Results === *)

"=== Advanced Features Examples Complete ==="
"✓ String interpolation and template strings"
"✓ Dot notation and method calls"
"✓ Arrow functions and lambda expressions"
"✓ Pipeline operators and data flow"
"✓ Modern syntax extensions"
"✓ Async/await pattern simulation"
"✓ Metaprogramming capabilities"
"✓ Module system simulation"
"✓ Advanced pattern matching"
"✓ Performance optimizations"

(* Feature demonstration statistics *)
"Advanced features results:"
"- String interpolations: " + ToString[5] + " different patterns"
"- Method calls: " + ToString[numbers_length] + " collection size"
"- Arrow functions: " + ToString[add_result] + " addition result"
"- Pipeline operations: " + ToString[pipeline_result] + " mathematical result"
"- Pattern matches: " + ToString[Length[match_tests]] + " test cases"
"- Memoized computations: " + ToString[Length[memo_results]] + " Fibonacci numbers"

(* Integration results *)
"Feature integration:"
"- Processed students: " + StringJoin[processed_students, ", "]
"- Text pipeline: " + text_pipeline
"- Method chaining: " + final_result
"- Namespace usage: Math square = " + ToString[math_square]
"- String utilities: Palindrome test = " + ToString[is_palindrome]

(* Performance metrics *)
"Performance analysis:"
"- Lazy sequence: " + ToString[lazy_values]
"- Memoization cache size: " + ToString[Length[Keys[cache]]]
"- Pipeline processing: " + ToString[Length[squared_odds]] + " squared odd numbers"
"- Pattern matching: " + ToString[Length[grade_results]] + " grades assigned"
"- Dynamic expressions: " + ToString[dynamic_expr] + " computed"

"All advanced language features demonstrated successfully!"